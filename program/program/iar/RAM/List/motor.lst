###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       22/Dec/2017  21:48:13
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\19071_000\Desktop\K60_Car\lib\peripheral\motor.c
#    Command line =  
#        -f C:\Users\19071_~1\AppData\Local\Temp\EWBA9F.tmp
#        (C:\Users\19071_000\Desktop\K60_Car\lib\peripheral\motor.c -D LPLD_K60
#        -D USE_K60DZ10 -lCN
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List -lB
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List -o
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\app\ -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\common\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\class\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\peripheral\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List\motor.lst
#    Object file  =  
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\Obj\motor.o
#
###############################################################################

C:\Users\19071_000\Desktop\K60_Car\lib\peripheral\motor.c
      1          #include "motor.h"
      2          #include <math.h>
      3          

   \                                 In section .bss, align 4
      4          static motor_controller_t *mtrctrl;
   \                     mtrctrl:
   \   00000000                      DS8 4
      5          

   \                                 In section .bss, align 4
      6          static uint32 average_num=0;
   \                     average_num:
   \   00000000                      DS8 4
      7          
      8          
      9          /*
     10          static void motor_controller__toggle_encoder(void){
     11              LPTMR0->CSR &= ~(LPTMR_CSR_TEN_MASK); // disable lptmr
     12              LPTMR0->CSR ^= LPTMR_CSR_TPS(3); // toggle between 0b01 and 0b10
     13              LPTMR0->CSR |= LPTMR_CSR_TEN_MASK; // enable lptmr
     14          }
     15          */

   \                                 In section .text, align 2, keep-with-next
     16          static void reckon__update(reckon_t * rec, long long tm, float ds, float r){
   \                     reckon__update: (+1)
   \   00000000   0xE92D 0x4DF0      PUSH     {R4-R8,R10,R11,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x9F08             LDR      R7,[SP, #+32]
   \   00000008   0xF8DD 0x8024      LDR      R8,[SP, #+36]
     17              rec->timestamp = tm;
   \   0000000C   0xE9C6 0x2300      STRD     R2,R3,[R6, #+0]
     18              rec->x += ds * cos(rec->theta);
   \   00000010   0x6930             LDR      R0,[R6, #+16]
   \   00000012   0x.... 0x....      BL       __aeabi_f2d
   \   00000016   0x.... 0x....      BL       cos
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0x000D             MOVS     R5,R1
   \   0000001E   0x68B0             LDR      R0,[R6, #+8]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4682             MOV      R10,R0
   \   00000026   0x468B             MOV      R11,R1
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x.... 0x....      BL       __aeabi_f2d
   \   0000002E   0x0022             MOVS     R2,R4
   \   00000030   0x002B             MOVS     R3,R5
   \   00000032   0x.... 0x....      BL       __aeabi_dmul
   \   00000036   0x4652             MOV      R2,R10
   \   00000038   0x465B             MOV      R3,R11
   \   0000003A   0x.... 0x....      BL       __aeabi_dadd
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x60B0             STR      R0,[R6, #+8]
     19              rec->y += ds * sin(rec->theta);
   \   00000044   0x6930             LDR      R0,[R6, #+16]
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x.... 0x....      BL       sin
   \   0000004E   0x0004             MOVS     R4,R0
   \   00000050   0x000D             MOVS     R5,R1
   \   00000052   0x68F0             LDR      R0,[R6, #+12]
   \   00000054   0x.... 0x....      BL       __aeabi_f2d
   \   00000058   0x4682             MOV      R10,R0
   \   0000005A   0x468B             MOV      R11,R1
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x0022             MOVS     R2,R4
   \   00000064   0x002B             MOVS     R3,R5
   \   00000066   0x.... 0x....      BL       __aeabi_dmul
   \   0000006A   0x4652             MOV      R2,R10
   \   0000006C   0x465B             MOV      R3,R11
   \   0000006E   0x.... 0x....      BL       __aeabi_dadd
   \   00000072   0x.... 0x....      BL       __aeabi_d2f
   \   00000076   0x60F0             STR      R0,[R6, #+12]
     20              if(r<1e5f) rec->theta -= ds / r;
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x47c35000
   \   0000007E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000082   0xD208             BCS.N    ??reckon__update_0
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x4641             MOV      R1,R8
   \   00000088   0x.... 0x....      BL       __aeabi_fdiv
   \   0000008C   0x0001             MOVS     R1,R0
   \   0000008E   0x6930             LDR      R0,[R6, #+16]
   \   00000090   0x.... 0x....      BL       __aeabi_fsub
   \   00000094   0x6130             STR      R0,[R6, #+16]
     21              //while(rec->theta > M_PI) rec->theta -= 2 * M_PI;
     22              //while(rec->theta < -M_PI) rec->theta += 2 * M_PI;
     23          }
   \                     ??reckon__update_0: (+1)
   \   00000096   0xE8BD 0x8DF0      POP      {R4-R8,R10,R11,PC}  ;; return
     24          
     25          static void motor_PID_controller (motor_controller_t *motor_set){
     26          
     27              static int32 delta_u_R, delta_u_L;
     28              static int32 u_R, u_L;
     29              static int32 Error_L, dError_L, ddError_L;
     30              static int32 Error_R, dError_R, ddError_R;
     31              int32 Current_value_R, Current_value_L;
     32              float pkp_R, pki_R, pkd_R;
     33              float pkp_L, pki_L, pkd_L;
     34              float current_value_R, current_value_L;
     35          
     36              if((motor_set->target_L) >= 710){
     37                current_value_L = ((float)(motor_set->ecdlft.signed_value) + 40.0f ) / 0.06f;
     38                Current_value_L = (int32)(current_value_L);
     39                Error_L = motor_set->target_L- Current_value_L;
     40                pkp_L=motor_set->pid_acc.Kp*Error_L;
     41                pki_L=motor_set->pid_acc.Ki*dError_L;
     42                pkd_L=motor_set->pid_acc.Kd*ddError_L;
     43              }
     44              else if ((motor_set->target_L) <= -710){
     45                current_value_L = ((float)(motor_set->ecdlft.signed_value) - 40.0f) / 0.06f;
     46                Current_value_L = (int32)(current_value_L);
     47                Error_L = motor_set->target_L- Current_value_L;
     48                pkp_L=motor_set->pid_acc.Kp*Error_L;
     49                pki_L=motor_set->pid_acc.Ki*dError_L;
     50                pkd_L=motor_set->pid_acc.Kd*ddError_L;
     51              }
     52              else{
     53                current_value_L = (float)(motor_set->ecdlft.signed_value)/ 0.07f;
     54                Current_value_L = (int32)(current_value_L);
     55                Error_L = motor_set->target_L- Current_value_L;
     56                pkp_L=motor_set->pid_brake.Kp*Error_L;
     57                pki_L=motor_set->pid_brake.Ki*dError_L;
     58                pkd_L=motor_set->pid_brake.Kd*ddError_L;
     59              }
     60          
     61              if((motor_set->target_R) >= 710){
     62                current_value_R = ((float)motor_set->ecdrgt.signed_value + 46.0f) / 0.0665f;
     63                Current_value_R = (int32)(current_value_R);
     64                Error_R = motor_set->target_R - Current_value_R;
     65                pkp_R=motor_set->pid_acc.Kp*Error_R;
     66                pki_R=motor_set->pid_acc.Ki*dError_R;
     67                pkd_R=motor_set->pid_acc.Kd*ddError_R;
     68              }
     69              else if ((motor_set->target_R) <= -710){
     70                current_value_R = ((float)motor_set->ecdrgt.signed_value - 46.0f) / 0.0665f;
     71                Current_value_R = (int32)(current_value_R);
     72                Error_R = motor_set->target_R - Current_value_R;
     73                pkp_R=motor_set->pid_acc.Kp*Error_R;
     74                pki_R=motor_set->pid_acc.Ki*dError_R;
     75                pkd_R=motor_set->pid_acc.Kd*ddError_R;
     76              }
     77              else{
     78                current_value_R = (float)(motor_set->ecdrgt.signed_value) / 0.07f;
     79                Current_value_R = (int32)(current_value_R);
     80                Error_R = motor_set->target_R - Current_value_R;
     81                pkp_R=motor_set->pid_brake.Kp*Error_R;
     82                pki_R=motor_set->pid_brake.Ki*dError_R;
     83                pkd_R=motor_set->pid_brake.Kd*ddError_R;
     84              }
     85          
     86              ddError_L = dError_L;
     87              ddError_R = dError_R;
     88              dError_L = Error_L;
     89              dError_R = Error_R;
     90          
     91              delta_u_L = (int32)(pkp_L - pki_L + pkd_L);
     92              delta_u_R = (int32)(pkp_R - pki_R + pkd_R);
     93          
     94              u_L += delta_u_L;
     95              u_R += delta_u_R;
     96          
     97              if( u_L > 3500 ) u_L = 3500;
     98              else if( u_L <-3500 ) u_L = -3500;
     99          
    100              if( u_R > 3500 ) u_R = 3500;
    101              else if( u_R <-3500 ) u_R = -3500;
    102          
    103              motor_controller__set_duty(LEFT_MOTOR, u_L);
    104              motor_controller__set_duty(RIGHT_MOTOR, u_R);
    105          
    106              //printf("%d\t%d\t%d\t%d\t%d\t%d\n", Current_value_R, motor_set->target_R, u_R,Current_value_L, motor_set->target_L, u_L); //打印
    107          }
    108          

   \                                 In section .text, align 2, keep-with-next
    109          static void pit_motor_controller(void){
   \                     pit_motor_controller: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    110              static uint32 pit_enter_counter;/* 进入此PIT中断次数计数器 */
    111              static uint16 placc_temp_value[2];
    112              static uint32 srv_duty;
    113          
    114              // 暂存 LPTMR 累加器的值并切换左右轮 LPTMR 的输入信号
    115              do{// 需要连续两次相同的读数才能保证读出正确，参见 K60 手册 41.4.5 节
    116                  placc_temp_value[0] = LPLD_LPTMR_GetPulseAcc();
   \                     ??pit_motor_controller_0: (+1)
   \   00000004   0x.... 0x....      BL       LPLD_LPTMR_GetPulseAcc
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   0000000C   0x8008             STRH     R0,[R1, #+0]
    117                  placc_temp_value[1] = LPLD_LPTMR_GetPulseAcc();
   \   0000000E   0x.... 0x....      BL       LPLD_LPTMR_GetPulseAcc
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   00000016   0x8048             STRH     R0,[R1, #+2]
    118              }while(abs_diff(placc_temp_value[0], placc_temp_value[1])>1);
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000001C   0x8800             LDRH     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable5_1
   \   00000022   0x8849             LDRH     R1,[R1, #+2]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD307             BCC.N    ??pit_motor_controller_1
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000002C   0x8801             LDRH     R1,[R0, #+0]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000032   0x8840             LDRH     R0,[R0, #+2]
   \   00000034   0x1A08             SUBS     R0,R1,R0
   \   00000036   0xE006             B.N      ??pit_motor_controller_2
   \                     ??pit_motor_controller_1: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000003C   0x8841             LDRH     R1,[R0, #+2]
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   00000042   0x8800             LDRH     R0,[R0, #+0]
   \   00000044   0x1A08             SUBS     R0,R1,R0
   \                     ??pit_motor_controller_2: (+1)
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xDADC             BGE.N    ??pit_motor_controller_0
    119              //motor_controller__toggle_encoder();
    120              
    121          
    122              // 更新光编的测量值
    123              switch(0){
    124              case 0:
    125                  mtrctrl->ecdlft.placc_value = placc_temp_value[1];// 读取暂存的累加值，代表左轮在一次PIT周期中转过的脉冲数
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \   0000004E   0x8840             LDRH     R0,[R0, #+2]
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0xF8A1 0x00C8      STRH     R0,[R1, #+200]
    126                  mtrctrl->ecdlft.signed_value = (
    127                      (PTxn_I(mtrctrl->ecdcfg_lft.DIR_PTx, mtrctrl->ecdcfg_lft.DIR_GPIO_Pinnum) ?
    128                          (int16)mtrctrl->ecdlft.placc_value :
    129                          -(int16)mtrctrl->ecdlft.placc_value)
    130                      );
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x68C0             LDR      R0,[R0, #+12]
   \   00000062   0x3010             ADDS     R0,R0,#+16
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x6949             LDR      R1,[R1, #+20]
   \   0000006C   0x0089             LSLS     R1,R1,#+2
   \   0000006E   0xEB11 0x1140      ADDS     R1,R1,R0, LSL #+5
   \   00000072   0xF111 0x4184      ADDS     R1,R1,#+1107296256
   \   00000076   0x6808             LDR      R0,[R1, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD005             BEQ.N    ??pit_motor_controller_3
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xF9B0 0x00C8      LDRSH    R0,[R0, #+200]
   \   00000086   0xE006             B.N      ??pit_motor_controller_4
   \                     ??pit_motor_controller_3: (+1)
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF9B0 0x00C8      LDRSH    R0,[R0, #+200]
   \   00000092   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000094   0x4240             RSBS     R0,R0,#+0
   \                     ??pit_motor_controller_4: (+1)
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0xF8A1 0x00CA      STRH     R0,[R1, #+202]
    131                  reckon__update(&(mtrctrl->reckon), systick__get(), mtrctrl->ecdlft.signed_value / 5.757f, servo__get_radius());
   \   000000A0   0x.... 0x....      BL       servo__get_radius
   \   000000A4   0x0006             MOVS     R6,R0
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF9B0 0x70CA      LDRSH    R7,[R0, #+202]
   \   000000B0   0x.... 0x....      BL       systick__get
   \   000000B4   0x0004             MOVS     R4,R0
   \   000000B6   0x000D             MOVS     R5,R1
   \   000000B8   0x9601             STR      R6,[SP, #+4]
   \   000000BA   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0x.... 0x....      BL       __aeabi_i2f
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable5_3  ;; 0x40b83958
   \   000000C6   0x.... 0x....      BL       __aeabi_fdiv
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x0022             MOVS     R2,R4
   \   000000CE   0x002B             MOVS     R3,R5
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x30D8             ADDS     R0,R0,#+216
   \   000000D8   0x.... 0x....      BL       reckon__update
    132                  break;
    133              case 1:
    134                  mtrctrl->ecdrgt.placc_value = placc_temp_value[1];// 读取暂存的累加值，代表右轮在一次PIT周期中转过的脉冲数
    135                  mtrctrl->ecdrgt.signed_value = (
    136                      (PTxn_I(mtrctrl->ecdcfg_rgt.DIR_PTx, mtrctrl->ecdcfg_rgt.DIR_GPIO_Pinnum) ?
    137                          -(int16)mtrctrl->ecdrgt.placc_value :
    138                          (int16)mtrctrl->ecdrgt.placc_value)
    139                      );
    140                  reckon__update(&(mtrctrl->reckon), systick__get(), mtrctrl->ecdrgt.signed_value / 5.757f, servo__get_radius());
    141                  break;
    142              }
    143              
    144              
    145              mtrctrl->ecdlft.mileage += mtrctrl->ecdlft.signed_value;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0xF9B0 0x00CA      LDRSH    R0,[R0, #+202]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   000000EA   0x6809             LDR      R1,[R1, #+0]
   \   000000EC   0xF8D1 0x10CC      LDR      R1,[R1, #+204]
   \   000000F0   0xFA01 0xF080      SXTAH    R0,R1,R0
   \   000000F4   0x....             LDR.N    R1,??DataTable5_2
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0xF8C1 0x00CC      STR      R0,[R1, #+204]
    146              mtrctrl->ecdrgt.mileage += mtrctrl->ecdrgt.signed_value;
   \   000000FC   0x....             LDR.N    R0,??DataTable5_2
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF9B0 0x00D2      LDRSH    R0,[R0, #+210]
   \   00000104   0x....             LDR.N    R1,??DataTable5_2
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0xF8D1 0x10D4      LDR      R1,[R1, #+212]
   \   0000010C   0xFA01 0xF080      SXTAH    R0,R1,R0
   \   00000110   0x....             LDR.N    R1,??DataTable5_2
   \   00000112   0x6809             LDR      R1,[R1, #+0]
   \   00000114   0xF8C1 0x00D4      STR      R0,[R1, #+212]
    147          
    148            //  motor_PID_controller (mtrctrl); // 电机PID控制
    149              average_num= mtrctrl->ecdlft.mileage;
   \   00000118   0x....             LDR.N    R0,??DataTable5_2
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF8D0 0x00CC      LDR      R0,[R0, #+204]
   \   00000120   0x....             LDR.N    R1,??DataTable5_4
   \   00000122   0x6008             STR      R0,[R1, #+0]
    150              pit_enter_counter++;
   \   00000124   0x....             LDR.N    R0,??DataTable5_5
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0x....             LDR.N    R1,??DataTable5_5
   \   0000012C   0x6008             STR      R0,[R1, #+0]
    151              
    152              
    153              /////////////////////////////////////////////////////////////////////
    154               LPTMR0->CSR&=(~LPTMR_CSR_TEN_MASK); 
   \   0000012E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40040000
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0x0840             LSRS     R0,R0,#+1
   \   00000134   0x0040             LSLS     R0,R0,#+1
   \   00000136   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40040000
   \   00000138   0x6008             STR      R0,[R1, #+0]
    155               LPTMR0->CSR |= LPTMR_CSR_TEN_MASK;
   \   0000013A   0x....             LDR.N    R0,??DataTable5_6  ;; 0x40040000
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000142   0x....             LDR.N    R1,??DataTable5_6  ;; 0x40040000
   \   00000144   0x6008             STR      R0,[R1, #+0]
    156              //if(pit_enter_counter>=300){
    157              //    average_num=mtrctrl->ecdlft.mileage/pit_enter_counter;
    158                  //motor_controller__set_duty(LEFT_MOTOR, (int32)(0));
    159                  //motor_controller__set_duty(RIGHT_MOTOR, (int32)(0));
    160              //    motor_controller__disable();
    161              //}
    162          }
   \   00000146   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .bss, align 4
   \                     `pit_motor_controller::pit_enter_counter`:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     `pit_motor_controller::placc_temp_value`:
   \   00000000                      DS8 4
    163          

   \                                 In section .text, align 2, keep-with-next
    164          void motor_controller__config(motor_controller_t * mtrctrl_usr){
   \                     motor_controller__config: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
    165              int8 i;
    166          
    167              mtrctrl = mtrctrl_usr;
   \   00000002   0x....             LDR.N    R1,??DataTable5_2
   \   00000004   0x6008             STR      R0,[R1, #+0]
    168          
    169              // PIT 周期中断初始化
    170              memset(&(mtrctrl->_pit_init), 0, sizeof(PIT_InitTypeDef));
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable5_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x3078             ADDS     R0,R0,#+120
   \   00000010   0x.... 0x....      BL       memset
    171              mtrctrl->_pit_init.PIT_Pitx = mtrctrl->pit;
   \   00000014   0x....             LDR.N    R0,??DataTable5_2
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable5_2
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0xF881 0x0078      STRB     R0,[R1, #+120]
    172              mtrctrl->_pit_init.PIT_PeriodMs = mtrctrl->period_ms;
   \   00000022   0x....             LDR.N    R0,??DataTable5_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x....             LDR.N    R1,??DataTable5_2
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xF8C1 0x0080      STR      R0,[R1, #+128]
    173              mtrctrl->_pit_init.PIT_Isr = pit_motor_controller;
   \   00000030   0x....             LDR.N    R0,??DataTable5_7
   \   00000032   0x....             LDR.N    R1,??DataTable5_2
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0xF8C1 0x0088      STR      R0,[R1, #+136]
    174              LPLD_PIT_Init(mtrctrl->_pit_init);
   \   0000003A   0x....             LDR.N    R0,??DataTable5_2
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF110 0x0178      ADDS     R1,R0,#+120
   \   00000042   0xB084             SUB      SP,SP,#+16
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x2214             MOVS     R2,#+20
   \   00000048   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000004C   0xBC0F             POP      {R0-R3}
   \   0000004E   0x.... 0x....      BL       LPLD_PIT_Init
    175          
    176              // LPTMR 初始化，从左轮先开始
    177              memset(&(mtrctrl->_lptmr_init), 0, sizeof(LPTMR_InitTypeDef));
   \   00000052   0x220C             MOVS     R2,#+12
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R0,??DataTable5_2
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x308C             ADDS     R0,R0,#+140
   \   0000005C   0x.... 0x....      BL       memset
    178              mtrctrl->_lptmr_init.LPTMR_Mode = LPTMR_MODE_PLACC;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable5_2
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0xF881 0x008C      STRB     R0,[R1, #+140]
    179              mtrctrl->_lptmr_init.LPTMR_PluseAccInput = mtrctrl->ecdcfg_rgt.LPTMR_ALTn;
   \   0000006A   0x....             LDR.N    R0,??DataTable5_2
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x7E00             LDRB     R0,[R0, #+24]
   \   00000070   0x....             LDR.N    R1,??DataTable5_2
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0xF881 0x0090      STRB     R0,[R1, #+144]
    180              LPLD_LPTMR_Init(mtrctrl->_lptmr_init);
   \   00000078   0x....             LDR.N    R0,??DataTable5_2
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x308C             ADDS     R0,R0,#+140
   \   0000007E   0xC807             LDM      R0,{R0-R2}
   \   00000080   0x.... 0x....      BL       LPLD_LPTMR_Init
    181              mtrctrl->_lptmr_init.LPTMR_PluseAccInput = mtrctrl->ecdcfg_lft.LPTMR_ALTn;
   \   00000084   0x....             LDR.N    R0,??DataTable5_2
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x7A00             LDRB     R0,[R0, #+8]
   \   0000008A   0x....             LDR.N    R1,??DataTable5_2
   \   0000008C   0x6809             LDR      R1,[R1, #+0]
   \   0000008E   0xF881 0x0090      STRB     R0,[R1, #+144]
    182              LPLD_LPTMR_Init(mtrctrl->_lptmr_init);
   \   00000092   0x....             LDR.N    R0,??DataTable5_2
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x308C             ADDS     R0,R0,#+140
   \   00000098   0xC807             LDM      R0,{R0-R2}
   \   0000009A   0x.... 0x....      BL       LPLD_LPTMR_Init
    183          
    184              // GPIO 初始化，用于光编方向判断
    185              mtrctrl->_ecd_dir_init.GPIO_PTx = mtrctrl->ecdcfg_lft.DIR_PTx;
   \   0000009E   0x....             LDR.N    R0,??DataTable5_2
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x68C0             LDR      R0,[R0, #+12]
   \   000000A4   0x....             LDR.N    R1,??DataTable5_2
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0xF8C1 0x0098      STR      R0,[R1, #+152]
    186              mtrctrl->_ecd_dir_init.GPIO_Pins = mtrctrl->ecdcfg_lft.DIR_GPIO_Pinn;
   \   000000AC   0x....             LDR.N    R0,??DataTable5_2
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x6900             LDR      R0,[R0, #+16]
   \   000000B2   0x....             LDR.N    R1,??DataTable5_2
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0xF8C1 0x009C      STR      R0,[R1, #+156]
    187              mtrctrl->_ecd_dir_init.GPIO_Dir = DIR_INPUT;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x....             LDR.N    R1,??DataTable5_2
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0xF881 0x00A4      STRB     R0,[R1, #+164]
    188              mtrctrl->_ecd_dir_init.GPIO_PinControl = INPUT_PULL_UP|IRQC_DIS;
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0x....             LDR.N    R1,??DataTable5_2
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF8C1 0x00A0      STR      R0,[R1, #+160]
    189              LPLD_GPIO_Init(mtrctrl->_ecd_dir_init);
   \   000000CE   0x....             LDR.N    R0,??DataTable5_2
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0xF110 0x0198      ADDS     R1,R0,#+152
   \   000000D6   0xB084             SUB      SP,SP,#+16
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x2214             MOVS     R2,#+20
   \   000000DC   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000E0   0xBC0F             POP      {R0-R3}
   \   000000E2   0x.... 0x....      BL       LPLD_GPIO_Init
    190              mtrctrl->_ecd_dir_init.GPIO_PTx = mtrctrl->ecdcfg_rgt.DIR_PTx;
   \   000000E6   0x....             LDR.N    R0,??DataTable5_2
   \   000000E8   0x6800             LDR      R0,[R0, #+0]
   \   000000EA   0x69C0             LDR      R0,[R0, #+28]
   \   000000EC   0x....             LDR.N    R1,??DataTable5_2
   \   000000EE   0x6809             LDR      R1,[R1, #+0]
   \   000000F0   0xF8C1 0x0098      STR      R0,[R1, #+152]
    191              mtrctrl->_ecd_dir_init.GPIO_Pins = mtrctrl->ecdcfg_rgt.DIR_GPIO_Pinn;
   \   000000F4   0x....             LDR.N    R0,??DataTable5_2
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x6A00             LDR      R0,[R0, #+32]
   \   000000FA   0x....             LDR.N    R1,??DataTable5_2
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0xF8C1 0x009C      STR      R0,[R1, #+156]
    192              mtrctrl->_ecd_dir_init.GPIO_Dir = DIR_INPUT;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x....             LDR.N    R1,??DataTable5_2
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0xF881 0x00A4      STRB     R0,[R1, #+164]
    193              mtrctrl->_ecd_dir_init.GPIO_PinControl = INPUT_PULL_UP|IRQC_DIS;
   \   0000010C   0x2003             MOVS     R0,#+3
   \   0000010E   0x....             LDR.N    R1,??DataTable5_2
   \   00000110   0x6809             LDR      R1,[R1, #+0]
   \   00000112   0xF8C1 0x00A0      STR      R0,[R1, #+160]
    194              LPLD_GPIO_Init(mtrctrl->_ecd_dir_init);
   \   00000116   0x....             LDR.N    R0,??DataTable5_2
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0xF110 0x0198      ADDS     R1,R0,#+152
   \   0000011E   0xB084             SUB      SP,SP,#+16
   \   00000120   0x4668             MOV      R0,SP
   \   00000122   0x2214             MOVS     R2,#+20
   \   00000124   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000128   0xBC0F             POP      {R0-R3}
   \   0000012A   0x.... 0x....      BL       LPLD_GPIO_Init
    195          
    196              // 编码器里程计清零
    197              mtrctrl->ecdlft.mileage = 0;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x....             LDR.N    R1,??DataTable5_2
   \   00000132   0x6809             LDR      R1,[R1, #+0]
   \   00000134   0xF8C1 0x00CC      STR      R0,[R1, #+204]
    198              mtrctrl->ecdrgt.mileage = 0;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x....             LDR.N    R1,??DataTable5_2
   \   0000013C   0x6809             LDR      R1,[R1, #+0]
   \   0000013E   0xF8C1 0x00D4      STR      R0,[R1, #+212]
    199          
    200              // 航位清零
    201              mtrctrl->reckon.timestamp = 0;
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x....             LDR.N    R2,??DataTable5_2
   \   00000148   0x6812             LDR      R2,[R2, #+0]
   \   0000014A   0xE9C2 0x0136      STRD     R0,R1,[R2, #+216]
    202              mtrctrl->reckon.x = 0;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0x....             LDR.N    R1,??DataTable5_2
   \   00000152   0x6809             LDR      R1,[R1, #+0]
   \   00000154   0xF8C1 0x00E0      STR      R0,[R1, #+224]
    203              mtrctrl->reckon.y = 0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x....             LDR.N    R1,??DataTable5_2
   \   0000015C   0x6809             LDR      R1,[R1, #+0]
   \   0000015E   0xF8C1 0x00E4      STR      R0,[R1, #+228]
    204              mtrctrl->reckon.theta = 0;
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0x....             LDR.N    R1,??DataTable5_2
   \   00000166   0x6809             LDR      R1,[R1, #+0]
   \   00000168   0xF8C1 0x00E8      STR      R0,[R1, #+232]
    205          
    206              // 电机驱动 FTM 初始化
    207              memset(&(mtrctrl->_mtr_init), 0, sizeof(FTM_InitTypeDef));
   \   0000016C   0x221C             MOVS     R2,#+28
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0x....             LDR.N    R0,??DataTable5_2
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0x30AC             ADDS     R0,R0,#+172
   \   00000176   0x.... 0x....      BL       memset
    208              for(i=0; i<MTR_LEN; i++){
   \   0000017A   0x2400             MOVS     R4,#+0
   \   0000017C   0xE048             B.N      ??motor_controller__config_0
    209                  mtrctrl->_mtr_init.FTM_Ftmx = mtrctrl->mtrcfg[i].FTMn;
   \                     ??motor_controller__config_1: (+1)
   \   0000017E   0x....             LDR.N    R0,??DataTable5_2
   \   00000180   0x6800             LDR      R0,[R0, #+0]
   \   00000182   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000184   0x210C             MOVS     R1,#+12
   \   00000186   0xFB14 0xF101      SMULBB   R1,R4,R1
   \   0000018A   0x4408             ADD      R0,R0,R1
   \   0000018C   0x6A80             LDR      R0,[R0, #+40]
   \   0000018E   0x....             LDR.N    R1,??DataTable5_2
   \   00000190   0x6809             LDR      R1,[R1, #+0]
   \   00000192   0xF8C1 0x00AC      STR      R0,[R1, #+172]
    210                  mtrctrl->_mtr_init.FTM_Mode = FTM_MODE_PWM; //使能PWM模式
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0x....             LDR.N    R1,??DataTable5_2
   \   0000019A   0x6809             LDR      R1,[R1, #+0]
   \   0000019C   0xF881 0x00B0      STRB     R0,[R1, #+176]
    211                  mtrctrl->_mtr_init.FTM_PwmFreq = mtrctrl->mtrcfg[i].freq;
   \   000001A0   0x....             LDR.N    R0,??DataTable5_2
   \   000001A2   0x6800             LDR      R0,[R0, #+0]
   \   000001A4   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   000001A6   0x210C             MOVS     R1,#+12
   \   000001A8   0xFB14 0xF101      SMULBB   R1,R4,R1
   \   000001AC   0x4408             ADD      R0,R0,R1
   \   000001AE   0x6B00             LDR      R0,[R0, #+48]
   \   000001B0   0x....             LDR.N    R1,??DataTable5_2
   \   000001B2   0x6809             LDR      R1,[R1, #+0]
   \   000001B4   0xF8C1 0x00B4      STR      R0,[R1, #+180]
    212                  LPLD_FTM_Init(mtrctrl->_mtr_init);
   \   000001B8   0x....             LDR.N    R0,??DataTable5_2
   \   000001BA   0x6800             LDR      R0,[R0, #+0]
   \   000001BC   0xF110 0x01AC      ADDS     R1,R0,#+172
   \   000001C0   0xB084             SUB      SP,SP,#+16
   \   000001C2   0x4668             MOV      R0,SP
   \   000001C4   0x221C             MOVS     R2,#+28
   \   000001C6   0x.... 0x....      BL       __aeabi_memcpy4
   \   000001CA   0xBC0F             POP      {R0-R3}
   \   000001CC   0x.... 0x....      BL       LPLD_FTM_Init
    213                  LPLD_FTM_PWM_Enable(mtrctrl->mtrcfg[i].FTMn,
    214                                      mtrctrl->mtrcfg[i].FTM_Chn,
    215                                      0, //初始化电机输出占空比为零
    216                                      mtrctrl->mtrcfg[i].PTXn,
    217                                      ALIGN_LEFT //脉宽左对齐
    218                                      );
   \   000001D0   0x2028             MOVS     R0,#+40
   \   000001D2   0x9000             STR      R0,[SP, #+0]
   \   000001D4   0x....             LDR.N    R0,??DataTable5_2
   \   000001D6   0x6800             LDR      R0,[R0, #+0]
   \   000001D8   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   000001DA   0x210C             MOVS     R1,#+12
   \   000001DC   0xFB14 0xF101      SMULBB   R1,R4,R1
   \   000001E0   0x4408             ADD      R0,R0,R1
   \   000001E2   0xF890 0x302D      LDRB     R3,[R0, #+45]
   \   000001E6   0x2200             MOVS     R2,#+0
   \   000001E8   0x....             LDR.N    R0,??DataTable5_2
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   000001EE   0x210C             MOVS     R1,#+12
   \   000001F0   0xFB14 0xF101      SMULBB   R1,R4,R1
   \   000001F4   0x4408             ADD      R0,R0,R1
   \   000001F6   0xF890 0x102C      LDRB     R1,[R0, #+44]
   \   000001FA   0x....             LDR.N    R0,??DataTable5_2
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000200   0x250C             MOVS     R5,#+12
   \   00000202   0xFB14 0xF505      SMULBB   R5,R4,R5
   \   00000206   0x4428             ADD      R0,R0,R5
   \   00000208   0x6A80             LDR      R0,[R0, #+40]
   \   0000020A   0x.... 0x....      BL       LPLD_FTM_PWM_Enable
    219              }
   \   0000020E   0x1C64             ADDS     R4,R4,#+1
   \                     ??motor_controller__config_0: (+1)
   \   00000210   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000212   0x2C04             CMP      R4,#+4
   \   00000214   0xDBB3             BLT.N    ??motor_controller__config_1
    220          }
   \   00000216   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void motor_controller__set_duty(motor_select_t sel, int32 duty){
   \                     motor_controller__set_duty: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x000E             MOVS     R6,R1
    223              mtr_ch_t chp, ch0;
    224          
    225              switch(sel){
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??motor_controller__set_duty_0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD008             BEQ.N    ??motor_controller__set_duty_1
   \   0000000E   0xE00F             B.N      ??motor_controller__set_duty_2
    226              case LEFT_MOTOR:
    227                  if(duty>=0){
   \                     ??motor_controller__set_duty_0: (+1)
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD402             BMI.N    ??motor_controller__set_duty_3
    228                      chp = MTR_LF;
   \   00000014   0x2500             MOVS     R5,#+0
    229                      ch0 = MTR_LR;
   \   00000016   0x2401             MOVS     R4,#+1
   \   00000018   0xE001             B.N      ??motor_controller__set_duty_4
    230                  }else{
    231                      chp = MTR_LR;
   \                     ??motor_controller__set_duty_3: (+1)
   \   0000001A   0x2501             MOVS     R5,#+1
    232                      ch0 = MTR_LF;
   \   0000001C   0x2400             MOVS     R4,#+0
    233                  }
    234                  break;
   \                     ??motor_controller__set_duty_4: (+1)
   \   0000001E   0xE00B             B.N      ??motor_controller__set_duty_5
    235              case RIGHT_MOTOR:
    236                  if(duty>=0){
   \                     ??motor_controller__set_duty_1: (+1)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD402             BMI.N    ??motor_controller__set_duty_6
    237                      chp = MTR_RF;
   \   00000024   0x2502             MOVS     R5,#+2
    238                      ch0 = MTR_RR;
   \   00000026   0x2403             MOVS     R4,#+3
   \   00000028   0xE001             B.N      ??motor_controller__set_duty_7
    239                  }else{
    240                      chp = MTR_RR;
   \                     ??motor_controller__set_duty_6: (+1)
   \   0000002A   0x2503             MOVS     R5,#+3
    241                      ch0 = MTR_RF;
   \   0000002C   0x2402             MOVS     R4,#+2
    242                  }
    243                  break;
   \                     ??motor_controller__set_duty_7: (+1)
   \   0000002E   0xE003             B.N      ??motor_controller__set_duty_5
    244              default:
    245                  ASSERT(0);
   \                     ??motor_controller__set_duty_2: (+1)
   \   00000030   0x21F5             MOVS     R1,#+245
   \   00000032   0x....             LDR.N    R0,??DataTable5_8
   \   00000034   0x.... 0x....      BL       assert_failed
    246              }
    247          
    248              if(duty<0) duty = -duty;
   \                     ??motor_controller__set_duty_5: (+1)
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD500             BPL.N    ??motor_controller__set_duty_8
   \   0000003C   0x4276             RSBS     R6,R6,#+0
    249          
    250              LPLD_FTM_PWM_ChangeDuty(mtrctrl->mtrcfg[chp].FTMn, mtrctrl->mtrcfg[chp].FTM_Chn, duty);
   \                     ??motor_controller__set_duty_8: (+1)
   \   0000003E   0x0032             MOVS     R2,R6
   \   00000040   0x....             LDR.N    R0,??DataTable5_2
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x210C             MOVS     R1,#+12
   \   00000048   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000004C   0x4408             ADD      R0,R0,R1
   \   0000004E   0xF890 0x102C      LDRB     R1,[R0, #+44]
   \   00000052   0x....             LDR.N    R0,??DataTable5_2
   \   00000054   0x6803             LDR      R3,[R0, #+0]
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x200C             MOVS     R0,#+12
   \   0000005A   0x4345             MULS     R5,R0,R5
   \   0000005C   0xEB03 0x0005      ADD      R0,R3,R5
   \   00000060   0x6A80             LDR      R0,[R0, #+40]
   \   00000062   0x.... 0x....      BL       LPLD_FTM_PWM_ChangeDuty
    251              LPLD_FTM_PWM_ChangeDuty(mtrctrl->mtrcfg[ch0].FTMn, mtrctrl->mtrcfg[ch0].FTM_Chn, 0);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x....             LDR.N    R0,??DataTable5_2
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x210C             MOVS     R1,#+12
   \   00000070   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000074   0x4408             ADD      R0,R0,R1
   \   00000076   0xF890 0x102C      LDRB     R1,[R0, #+44]
   \   0000007A   0x....             LDR.N    R0,??DataTable5_2
   \   0000007C   0x6803             LDR      R3,[R0, #+0]
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x200C             MOVS     R0,#+12
   \   00000082   0x4344             MULS     R4,R0,R4
   \   00000084   0xEB03 0x0004      ADD      R0,R3,R4
   \   00000088   0x6A80             LDR      R0,[R0, #+40]
   \   0000008A   0x.... 0x....      BL       LPLD_FTM_PWM_ChangeDuty
    252          }
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
    253          

   \                                 In section .text, align 2, keep-with-next
    254          void motor_controller__enable(){
   \                     motor_controller__enable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255              LPLD_PIT_EnableIrq(mtrctrl->_pit_init);
   \   00000002   0x....             LDR.N    R0,??DataTable5_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF110 0x0178      ADDS     R1,R0,#+120
   \   0000000A   0xB084             SUB      SP,SP,#+16
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000014   0xBC0F             POP      {R0-R3}
   \   00000016   0x.... 0x....      BL       LPLD_PIT_EnableIrq
    256          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    257          

   \                                 In section .text, align 2, keep-with-next
    258          void motor_controller__disable(){
   \                     motor_controller__disable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    259              LPLD_PIT_DisableIrq(mtrctrl->_pit_init);
   \   00000002   0x....             LDR.N    R0,??DataTable5_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF110 0x0178      ADDS     R1,R0,#+120
   \   0000000A   0xB084             SUB      SP,SP,#+16
   \   0000000C   0x4668             MOV      R0,SP
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000014   0xBC0F             POP      {R0-R3}
   \   00000016   0x.... 0x....      BL       LPLD_PIT_DisableIrq
    260          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x47C35000         DC32     0x47c35000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     `pit_motor_controller::placc_temp_value`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     mtrctrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40B83958         DC32     0x40b83958

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     average_num

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     `pit_motor_controller::pit_enter_counter`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     pit_motor_controller

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x31          DC8 5CH, 31H, 39H, 30H, 37H, 31H, 5FH, 30H
   \              0x39 0x30    
   \              0x37 0x31    
   \              0x5F 0x30    
   \   00000010   0x30 0x30          DC8 30H, 30H, 5CH, 44H, 65H, 73H, 6BH, 74H
   \              0x5C 0x44    
   \              0x65 0x73    
   \              0x6B 0x74    
   \   00000018   0x6F 0x70          DC8 6FH, 70H, 5CH, 4BH, 36H, 30H, 5FH, 43H
   \              0x5C 0x4B    
   \              0x36 0x30    
   \              0x5F 0x43    
   \   00000020   0x61 0x72          DC8 61H, 72H, 5CH, 6CH, 69H, 62H, 5CH, 70H
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x70    
   \   00000028   0x65 0x72          DC8 65H, 72H, 69H, 70H, 68H, 65H, 72H, 61H
   \              0x69 0x70    
   \              0x68 0x65    
   \              0x72 0x61    
   \   00000030   0x6C 0x5C          DC8 6CH, 5CH, 6DH, 6FH, 74H, 6FH, 72H, 2EH
   \              0x6D 0x6F    
   \              0x74 0x6F    
   \              0x72 0x2E    
   \   00000038   0x63 0x00          DC8 63H, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   motor_controller__config
        24   -> LPLD_FTM_Init
        24   -> LPLD_FTM_PWM_Enable
        24   -> LPLD_GPIO_Init
        24   -> LPLD_LPTMR_Init
        24   -> LPLD_PIT_Init
        40   -> __aeabi_memcpy4
        24   -> memset
      24   motor_controller__disable
         8   -> LPLD_PIT_DisableIrq
        24   -> __aeabi_memcpy4
      24   motor_controller__enable
         8   -> LPLD_PIT_EnableIrq
        24   -> __aeabi_memcpy4
      16   motor_controller__set_duty
        16   -> LPLD_FTM_PWM_ChangeDuty
        16   -> assert_failed
      32   pit_motor_controller
        32   -> LPLD_LPTMR_GetPulseAcc
        32   -> __aeabi_fdiv
        32   -> __aeabi_i2f
        32   -> reckon__update
        32   -> servo__get_radius
        32   -> systick__get
      32   reckon__update
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fdiv
        32   -> __aeabi_fsub
        32   -> cos
        32   -> sin
        32 __aeabi_cfcmple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
      60  ?_0
       4  average_num
     536  motor_controller__config
      28  motor_controller__disable
      28  motor_controller__enable
     144  motor_controller__set_duty
       4  mtrctrl
       4  pit_enter_counter
     328  pit_motor_controller
       4  placc_temp_value
     154  reckon__update

 
    16 bytes in section .bss
    60 bytes in section .rodata
 1 254 bytes in section .text
 
 1 254 bytes of CODE  memory
    60 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: 5
