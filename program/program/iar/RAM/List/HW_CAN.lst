###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       22/Dec/2017  21:48:10
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\19071_000\Desktop\K60_Car\lib\LPLD\HW\HW_CAN.c
#    Command line =  
#        -f C:\Users\19071_~1\AppData\Local\Temp\EWAFAB.tmp
#        (C:\Users\19071_000\Desktop\K60_Car\lib\LPLD\HW\HW_CAN.c -D LPLD_K60
#        -D USE_K60DZ10 -lCN
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List -lB
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List -o
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\app\ -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\common\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\USB\class\
#        -I
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\..\..\..\lib\peripheral\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\List\HW_CAN.lst
#    Object file  =  
#        C:\Users\19071_000\Desktop\K60_Car\program\program\iar\RAM\Obj\HW_CAN.o
#
###############################################################################

C:\Users\19071_000\Desktop\K60_Car\lib\LPLD\HW\HW_CAN.c
      1          /**
      2           * @file HW_CAN.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-3-9
      5           * @brief CAN底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0xe000e100
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0940             LSRS     R0,R0,#+5
   \   00000016   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \   00000000   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD409             BMI.N    ??__NVIC_DisableIRQ_0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000C   0x408A             LSLS     R2,R2,R1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0xe000e180
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0x0940             LSRS     R0,R0,#+5
   \   00000016   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
     24          #include "HW_CAN.h"
     25          //FlexCAN模块设置波特率函数
     26          static void LPLD_CAN_SetBaudRate(CAN_Type *,uint32 );
     27          //FlexCAN 清楚中断标志位函数
     28          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *, uint8 );
     29          //FlexCAN 获得中断标志位函数
     30          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *, uint8 );
     31          //FlexCAN 解锁Msg缓冲区函数
     32          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *);
     33          //FlexCAN 使能Msg缓冲区中断函数
     34          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *, uint8 );
     35          //FlexCAN 设置Msg缓冲区的CODE
     36          static void LPLD_CAN_SetMsgCode(CAN_Type *, uint8 , uint8 );
     37          //FlexCAN 获得Msg缓冲区的CODE
     38          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *, uint8 );
     39          //FlexCAN 获得Msg缓冲区的TIMESTAMP
     40          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *, uint8 );
     41          //FlexCAN 设置Msg缓冲区的ID
     42          void LPLD_CAN_SetMsgID(CAN_Type *, uint8 ,uint8, uint32 );
     43          //FlexCAN 获得Msg缓冲区的ID
     44          static uint32 LPLD_CAN_GetMsgID(CAN_Type *, uint8 );
     45          //FlexCAN 获得Msg缓冲区的长度
     46          uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 MSG_NUM);
     47          //FlexCAN 获得Msg缓冲区的数据
     48          static void LPLD_CAN_GetData(CAN_Type *canx, uint8 , uint8 ,  uint8 *);
     49          //FlexCAN 写Msg缓冲区的数据
     50          static void LPLD_CAN_WriteData(CAN_Type *, uint8 , uint8, uint8 * );
     51          //FlexCAN 传输中断函数
     52          void LPLD_CAN_Transmit_Interrupt(CAN_Type *, uint8 );
     53          //FlexCAN 接收中断函数
     54          static void LPLD_CAN_Receive_Interrupt(CAN_Type *, uint8 );
     55          //FlexCAN CANx的中断处理函数
     56          static void LPLD_CAN_MB_ISR(void);
     57          //设置16个Msg的结构体

   \                                 In section .bss, align 4
     58          CAN_MSGOBJ_InitTypeDef  flexcan_msgobj_param_t[MSG_MAX_NO] = {0};
   \                     flexcan_msgobj_param_t:
   \   00000000                      DS8 256
     59          //设置CANx Msg的中断回掉函数

   \                                 In section .bss, align 4
     60          CAN_ISR_CALLBACK CAN0_ISR[MSG_MAX_NO];
   \                     CAN0_ISR:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
     61          CAN_ISR_CALLBACK CAN1_ISR[MSG_MAX_NO];
   \                     CAN1_ISR:
   \   00000000                      DS8 64
     62          
     63          /*
     64           * LPLD_CAN_Init
     65           * 在该函数中使能CANx，设置CANx的波特率，选择相应的工作模式
     66           * 通过CAN_InitTypeDef结构体对CAN进行初始化。
     67           * 
     68           * 参数:
     69           *    CAN_InitTypeDef--can_init_structure
     70           *                     具体定义见HW_CAN.h can_init_structure
     71           *
     72           * 输出:
     73           *    无
     74           *
     75           */

   \                                 In section .text, align 2, keep-with-next
     76          void LPLD_CAN_Init(CAN_InitTypeDef can_init_structure)
     77          {
   \                     LPLD_CAN_Init: (+1)
   \   00000000   0xE92D 0x41F7      PUSH     {R0-R2,R4-R8,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
     78            uint8 i;
     79            CAN_Type *canx = can_init_structure.CAN_Canx;
   \   00000006   0x9C01             LDR      R4,[SP, #+4]
     80            uint32 baud = can_init_structure.CAN_BaudRate;
   \   00000008   0x9D02             LDR      R5,[SP, #+8]
     81            uint8  mask_mode = can_init_structure.CAN_RxMaskMode;
   \   0000000A   0xF89D 0x600C      LDRB     R6,[SP, #+12]
     82            PortPinsEnum_Type tx_pin = can_init_structure.CAN_TxPin;
   \   0000000E   0xF89D 0x700D      LDRB     R7,[SP, #+13]
     83            PortPinsEnum_Type rx_pin = can_init_structure.CAN_RxPin;
   \   00000012   0xF89D 0x800E      LDRB     R8,[SP, #+14]
     84          
     85            ASSERT(mask_mode <= CAN_MSGOBJ_GLOBAL_MASKING);
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E02             CMP      R6,#+2
   \   0000001A   0xDB04             BLT.N    ??LPLD_CAN_Init_0
   \   0000001C   0x2155             MOVS     R1,#+85
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000022   0x.... 0x....      BL       assert_failed
     86            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \                     ??LPLD_CAN_Init_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0xf4241
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD304             BCC.N    ??LPLD_CAN_Init_1
   \   0000002E   0x2156             MOVS     R1,#+86
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000034   0x.... 0x....      BL       assert_failed
     87              
     88          #if defined(CPU_MK60DZ10) || defined(CPU_MK60D10)  
     89            OSC->CR |= OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK;
   \                     ??LPLD_CAN_Init_1: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable19_4  ;; 0x40065000
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable19_4  ;; 0x40065000
   \   00000046   0x7008             STRB     R0,[R1, #+0]
     90          #elif defined(CPU_MK60F12) || defined(CPU_MK60F15)
     91            OSC0->CR |= OSC_CR_ERCLKEN_MASK | OSC_CR_EREFSTEN_MASK;
     92          #endif    
     93            if(canx == CAN0)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD108             BNE.N    ??LPLD_CAN_Init_2
     94              SIM->SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable19_6  ;; 0x4004803c
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable19_6  ;; 0x4004803c
   \   0000005E   0x6008             STR      R0,[R1, #+0]
   \   00000060   0xE007             B.N      ??LPLD_CAN_Init_3
     95            else
     96              SIM->SCGC3 |= SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Init_2: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable19_7  ;; 0x40048030
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable19_7  ;; 0x40048030
   \   00000070   0x6008             STR      R0,[R1, #+0]
     97            
     98            if(canx == CAN0)
   \                     ??LPLD_CAN_Init_3: (+1)
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD11E             BNE.N    ??LPLD_CAN_Init_4
     99            {
    100              if(tx_pin == PTB18)//CAN0_TX
   \   0000007A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007C   0x2F32             CMP      R7,#+50
   \   0000007E   0xD105             BNE.N    ??LPLD_CAN_Init_5
    101              {
    102                PORTB->PCR[18] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   00000080   0xF240 0x2003      MOVW     R0,#+515
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable19_8  ;; 0x4004a048
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE004             B.N      ??LPLD_CAN_Init_6
    103              }
    104              else
    105              {
    106                PORTA->PCR[12] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_5: (+1)
   \   0000008C   0xF44F 0x7000      MOV      R0,#+512
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable19_9  ;; 0x40049030
   \   00000094   0x6008             STR      R0,[R1, #+0]
    107              }
    108          
    109              if(rx_pin == PTB19)//CAN0_RX
   \                     ??LPLD_CAN_Init_6: (+1)
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0xF1B8 0x0F33      CMP      R8,#+51
   \   0000009E   0xD105             BNE.N    ??LPLD_CAN_Init_7
    110              {
    111                PORTB->PCR[19] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000A0   0xF240 0x2003      MOVW     R0,#+515
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable19_10  ;; 0x4004a04c
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE023             B.N      ??LPLD_CAN_Init_8
    112              }
    113              else
    114              {
    115                PORTA->PCR[13] = PORT_PCR_MUX(2); 
   \                     ??LPLD_CAN_Init_7: (+1)
   \   000000AC   0xF44F 0x7000      MOV      R0,#+512
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19_11  ;; 0x40049034
   \   000000B4   0x6008             STR      R0,[R1, #+0]
   \   000000B6   0xE01D             B.N      ??LPLD_CAN_Init_8
    116              }
    117            }
    118            else
    119            {
    120              if(tx_pin == PTC17)//CAN1_TX
   \                     ??LPLD_CAN_Init_4: (+1)
   \   000000B8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000BA   0x2F4D             CMP      R7,#+77
   \   000000BC   0xD105             BNE.N    ??LPLD_CAN_Init_9
    121              {
    122                PORTC->PCR[17] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000BE   0xF240 0x2003      MOVW     R0,#+515
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable19_12  ;; 0x4004b044
   \   000000C6   0x6008             STR      R0,[R1, #+0]
   \   000000C8   0xE004             B.N      ??LPLD_CAN_Init_10
    123              }
    124              else
    125              {
    126                PORTE->PCR[24] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_9: (+1)
   \   000000CA   0xF240 0x2003      MOVW     R0,#+515
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable19_13  ;; 0x4004d060
   \   000000D2   0x6008             STR      R0,[R1, #+0]
    127              }
    128          
    129              if(rx_pin == PTC16)//CAN1_RX
   \                     ??LPLD_CAN_Init_10: (+1)
   \   000000D4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D8   0xF1B8 0x0F4C      CMP      R8,#+76
   \   000000DC   0xD105             BNE.N    ??LPLD_CAN_Init_11
    130              {
    131                PORTC->PCR[16] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK; 
   \   000000DE   0xF240 0x2003      MOVW     R0,#+515
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable19_14  ;; 0x4004b040
   \   000000E6   0x6008             STR      R0,[R1, #+0]
   \   000000E8   0xE004             B.N      ??LPLD_CAN_Init_8
    132              }
    133              else
    134              {
    135                PORTE->PCR[25] = PORT_PCR_MUX(2)| PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   \                     ??LPLD_CAN_Init_11: (+1)
   \   000000EA   0xF240 0x2003      MOVW     R0,#+515
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable19_15  ;; 0x4004d064
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    136              }
    137            } 
    138            //禁止CAN外设
    139            canx->MCR   |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Init_8: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   000000FA   0x6020             STR      R0,[R4, #+0]
    140            //只有在LPM_ACK = 1情况下才可以选择钟源
    141            canx->CTRL1 |= CAN_CTRL1_CLKSRC_MASK;  //选择peripheral clock作为CAN外设的时钟源
   \   000000FC   0x6860             LDR      R0,[R4, #+4]
   \   000000FE   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000102   0x6060             STR      R0,[R4, #+4]
    142                                                   //设置此位必须在CAN停止模式下
    143            //在时钟初始化完毕和CAN总线使能完毕后，
    144            //单片机自动进入冻结模式
    145            //只有在冻结模式下才能配置大多数CAN总线寄存器
    146            //使能冻结模式 
    147            canx->MCR |= CAN_MCR_FRZ_MASK;
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   0000010A   0x6020             STR      R0,[R4, #+0]
    148            canx->MCR &= ~CAN_MCR_MDIS_MASK; 
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000112   0x6020             STR      R0,[R4, #+0]
    149            
    150            while(!(canx->MCR & CAN_MCR_LPMACK_MASK));	
   \                     ??LPLD_CAN_Init_12: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x02C0             LSLS     R0,R0,#+11
   \   00000118   0xD5FC             BPL.N    ??LPLD_CAN_Init_12
    151          
    152            //进行软件复位
    153            canx->MCR ^= CAN_MCR_SOFTRST_MASK;
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0xF090 0x7000      EORS     R0,R0,#0x2000000
   \   00000120   0x6020             STR      R0,[R4, #+0]
    154            while(canx->MCR & CAN_MCR_SOFTRST_MASK);
   \                     ??LPLD_CAN_Init_13: (+1)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x0180             LSLS     R0,R0,#+6
   \   00000126   0xD4FC             BMI.N    ??LPLD_CAN_Init_13
    155                      
    156            //等待进入冻结模式 
    157            while(!(canx->MCR & CAN_MCR_FRZACK_MASK));
   \                     ??LPLD_CAN_Init_14: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x01C0             LSLS     R0,R0,#+7
   \   0000012C   0xD5FC             BPL.N    ??LPLD_CAN_Init_14
    158            
    159            if(mask_mode == CAN_MSGOBJ_GLOBAL_MASKING)
   \   0000012E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000130   0x2E01             CMP      R6,#+1
   \   00000132   0xD104             BNE.N    ??LPLD_CAN_Init_15
    160            {
    161              canx->MCR &= ~CAN_MCR_IRMQ_MASK;   //使能全局匹配寄存器禁止单独匹配 
   \   00000134   0x6820             LDR      R0,[R4, #+0]
   \   00000136   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000013A   0x6020             STR      R0,[R4, #+0]
   \   0000013C   0xE003             B.N      ??LPLD_CAN_Init_16
    162            }
    163            else
    164            {
    165              canx->MCR |= CAN_MCR_IRMQ_MASK;   //使能Msg单独匹配 
   \                     ??LPLD_CAN_Init_15: (+1)
   \   0000013E   0x6820             LDR      R0,[R4, #+0]
   \   00000140   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000144   0x6020             STR      R0,[R4, #+0]
    166            }
    167            //将MB_MAX个邮箱缓冲区内容清0
    168            for(i = 0;i < MSG_MAX_NO; i++)
   \                     ??LPLD_CAN_Init_16: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xE018             B.N      ??LPLD_CAN_Init_17
    169            {
    170              canx->MB[i].CS    = 0x00000000;
   \                     ??LPLD_CAN_Init_18: (+1)
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x0102             LSLS     R2,R0,#+4
   \   00000150   0x4422             ADD      R2,R4,R2
   \   00000152   0xF8C2 0x1080      STR      R1,[R2, #+128]
    171              canx->MB[i].ID    = 0x00000000;
   \   00000156   0x2100             MOVS     R1,#+0
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x0102             LSLS     R2,R0,#+4
   \   0000015C   0x4422             ADD      R2,R4,R2
   \   0000015E   0xF8C2 0x1084      STR      R1,[R2, #+132]
    172              canx->MB[i].WORD0 = 0x00000000;
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000166   0x0102             LSLS     R2,R0,#+4
   \   00000168   0x4422             ADD      R2,R4,R2
   \   0000016A   0xF8C2 0x1088      STR      R1,[R2, #+136]
    173              canx->MB[i].WORD1 = 0x00000000;        
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x0102             LSLS     R2,R0,#+4
   \   00000174   0x4422             ADD      R2,R4,R2
   \   00000176   0xF8C2 0x108C      STR      R1,[R2, #+140]
    174            }
   \   0000017A   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPLD_CAN_Init_17: (+1)
   \   0000017C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017E   0x2810             CMP      R0,#+16
   \   00000180   0xDBE3             BLT.N    ??LPLD_CAN_Init_18
    175            
    176            canx->MCR |= CAN_MCR_SRXDIS_MASK ; //禁止自我接收
   \   00000182   0x6820             LDR      R0,[R4, #+0]
   \   00000184   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000188   0x6020             STR      R0,[R4, #+0]
    177            //canx->MCR |= CAN_MCR_RFEN_MASK ;   //使能接收FIFO
    178            //canx->CTRL2 |= CAN_CTRL2_RFFN(0);
    179            //canx->MCR |= CAN_MCR_IDAM(0);
    180            
    181            //配置相关的寄存器
    182            canx->CTRL2 &= ~CAN_CTRL2_EACEN_MASK; //接收邮箱过滤IDE匹配，RTR不匹配
   \   0000018A   0x6B60             LDR      R0,[R4, #+52]
   \   0000018C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   00000190   0x6360             STR      R0,[R4, #+52]
    183            canx->CTRL2 &= ~CAN_CTRL2_RRS_MASK;  //不自动产生远程请求帧产生
   \   00000192   0x6B60             LDR      R0,[R4, #+52]
   \   00000194   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   00000198   0x6360             STR      R0,[R4, #+52]
    184            canx->CTRL2 &= ~CAN_CTRL2_MRP_MASK;   //ID首先从邮箱中匹配
   \   0000019A   0x6B60             LDR      R0,[R4, #+52]
   \   0000019C   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000001A0   0x6360             STR      R0,[R4, #+52]
    185          
    186            //canx->CTRL1 |= CAN_CTRL1_LBUF_MASK;  //发送的时候从低Msg开始
    187            canx->CTRL1 &= ~CAN_CTRL1_LBUF_MASK;   //发送的时候从低优先级发送
   \   000001A2   0x6860             LDR      R0,[R4, #+4]
   \   000001A4   0xF030 0x0010      BICS     R0,R0,#0x10
   \   000001A8   0x6060             STR      R0,[R4, #+4]
    188                                       
    189            //canx->CTRL1 |= CAN_CTRL1_LPB_MASK;  //loop 模式,用于测试
    190            canx->CTRL1 &= ~CAN_CTRL1_LPB_MASK;   //使用正常模式
   \   000001AA   0x6860             LDR      R0,[R4, #+4]
   \   000001AC   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   000001B0   0x6060             STR      R0,[R4, #+4]
    191            //设置CAN总线通信的波特率
    192            LPLD_CAN_SetBaudRate(canx,baud);
   \   000001B2   0x0029             MOVS     R1,R5
   \   000001B4   0x0020             MOVS     R0,R4
   \   000001B6   0x.... 0x....      BL       LPLD_CAN_SetBaudRate
    193          
    194            //清空CAN自由计数器 
    195            canx->TIMER = 0x0000; 
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0x60A0             STR      R0,[R4, #+8]
    196             /*
    197            如果MCR的IRMQ为1，表示每个邮箱都可以单独进行ID匹配
    198            注意：如果是low cost MCUs（低配置的MCU），没有单独匹配这项功能。
    199                    1\ID匹配会选择free to receive状态的邮箱作为胜者，
    200                    获胜的邮箱可以从接收缓冲区内将接收的帧 Move in 到MB中；
    201                    2\如果出现ID号相同的邮箱，会首先从序号低的邮箱进行匹配，如果
    202                    低序号邮箱是non free to receive状态，那么匹配过程将会查找
    203                    下一个邮箱直到找到free to receive状态且ID相同的邮箱；
    204                    3\如果ID号相同的邮箱都处于non free to receive状态，那么匹配过程
    205                    将停止在最后一个有相同ID的邮箱位置，将帧Move in 到MB中并且将该邮
    206                    箱的状态设置成OVERRUN。
    207                    RXIMR[i]存储在单片机的RAM中，只有在CAN冻结模式下可写。
    208                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK不起作用
    209            */
    210            if(canx->MCR & CAN_MCR_IRMQ_MASK)
   \   000001BE   0x6820             LDR      R0,[R4, #+0]
   \   000001C0   0x03C0             LSLS     R0,R0,#+15
   \   000001C2   0xD50C             BPL.N    ??LPLD_CAN_Init_19
    211            {
    212              for(i = 0;i < MSG_MAX_NO; i++)
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0xE007             B.N      ??LPLD_CAN_Init_20
    213              {
    214                canx->RXIMR[i] = 0x1FFFFFFFL;//设置邮箱29位全部屏蔽
   \                     ??LPLD_CAN_Init_21: (+1)
   \   000001C8   0xF07F 0x4160      MVNS     R1,#-536870912
   \   000001CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CE   0xEB04 0x0280      ADD      R2,R4,R0, LSL #+2
   \   000001D2   0xF8C2 0x1880      STR      R1,[R2, #+2176]
    215              }
   \   000001D6   0x1C40             ADDS     R0,R0,#+1
   \                     ??LPLD_CAN_Init_20: (+1)
   \   000001D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DA   0x2810             CMP      R0,#+16
   \   000001DC   0xDBF4             BLT.N    ??LPLD_CAN_Init_21
    216            } 
    217           /*
    218            如果MCR的IRMQ为0，表示使用全局匹配寄存器进行匹配，
    219                    此时CANx_RXMGMASK、CANx_RX14MASK、CANx_RX15MASK起作用；
    220                    CANx_RXMGMASK管理除CANx_RX14MASK、CANx_RX15MASK以外的所有Msg；
    221                    ID匹配过程会停止在找到的第一个ID相同的邮箱位置，不管该邮箱是否处于
    222                    free to receive状态。
    223            */
    224          
    225            canx->RXMGMASK = 0x1FFFFFFF; //29位ID全部匹配            
   \                     ??LPLD_CAN_Init_19: (+1)
   \   000001DE   0xF07F 0x4060      MVNS     R0,#-536870912
   \   000001E2   0x6120             STR      R0,[R4, #+16]
    226            canx->RX14MASK = 0x1FFFFFFF;
   \   000001E4   0xF07F 0x4060      MVNS     R0,#-536870912
   \   000001E8   0x6160             STR      R0,[R4, #+20]
    227            canx->RX15MASK = 0x1FFFFFFF; 
   \   000001EA   0xF07F 0x4060      MVNS     R0,#-536870912
   \   000001EE   0x61A0             STR      R0,[R4, #+24]
    228           
    229            canx->MCR &= ~(CAN_MCR_HALT_MASK); 
   \   000001F0   0x6820             LDR      R0,[R4, #+0]
   \   000001F2   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   000001F6   0x6020             STR      R0,[R4, #+0]
    230            //等到不在冻结模式，休眠模式或者停止模式
    231            while( canx->MCR & CAN_MCR_FRZACK_MASK); 
   \                     ??LPLD_CAN_Init_22: (+1)
   \   000001F8   0x6820             LDR      R0,[R4, #+0]
   \   000001FA   0x01C0             LSLS     R0,R0,#+7
   \   000001FC   0xD4FC             BMI.N    ??LPLD_CAN_Init_22
    232            
    233            while( canx->MCR & CAN_MCR_NOTRDY_MASK);
   \                     ??LPLD_CAN_Init_23: (+1)
   \   000001FE   0x6820             LDR      R0,[R4, #+0]
   \   00000200   0x0100             LSLS     R0,R0,#+4
   \   00000202   0xD4FC             BMI.N    ??LPLD_CAN_Init_23
    234          }
   \   00000204   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
    235          /*
    236           * LPLD_CAN_SetBaudRate
    237           * 设置CAN波特率,PLL必须是100Mhz
    238           * 参数:
    239           *    CAN_Type *canx
    240           *      |___CAN0 --CAN0号模块
    241           *      |___CAN1 --CAN0号模块
    242           *    baud 波特率
    243           *      |__CAN_BAUD_RATE_50KBPS  --波特率50KBPS
    244           *      |__CAN_BAUD_RATE_100KBPS --波特率100KBPS
    245           *      |__CAN_BAUD_RATE_250KBPS --波特率250KBPS
    246           *      |__CAN_BAUD_RATE_500KBPS --波特率500KBPS
    247           *      |__CAN_BAUD_RATE_1MBPS   --波特率1MBPS
    248           *  输出：
    249           *    无
    250          */

   \                                 In section .text, align 2, keep-with-next
    251          static void LPLD_CAN_SetBaudRate(CAN_Type *canx,uint32 baud)
    252          {
   \                     LPLD_CAN_SetBaudRate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    253            uint8 prescale;
    254            //1个CAN总线位的时间量子：Time Quanta = SYNC_SEG + (PROP_SEG + PSEG1 + 2) + (PSEG2 + 1)，
    255            //SYNC_SEG =  1 （固定值）
    256            ASSERT(baud <= CAN_BAUD_RATE_1MBPS);
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0xf4241
   \   0000000A   0x4285             CMP      R5,R0
   \   0000000C   0xD305             BCC.N    ??LPLD_CAN_SetBaudRate_0
   \   0000000E   0xF44F 0x7180      MOV      R1,#+256
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000016   0x.... 0x....      BL       assert_failed
    257            switch(baud)
   \                     ??LPLD_CAN_SetBaudRate_0: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xF248 0x2135      MOVW     R1,#+33333
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD029             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   00000024   0xF24C 0x3150      MOVW     R1,#+50000
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD034             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable19_16  ;; 0x14585
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD021             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable19_17  ;; 0x186a0
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD01D             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable19_18  ;; 0x1e848
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD019             BEQ.N    ??LPLD_CAN_SetBaudRate_1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable19_19  ;; 0x3d090
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD024             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable19_20  ;; 0x7a120
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD020             BEQ.N    ??LPLD_CAN_SetBaudRate_2
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19_21  ;; 0xf4240
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD12B             BNE.N    ??LPLD_CAN_SetBaudRate_3
    258            {
    259              case CAN_BAUD_RATE_1MBPS:
    260                {
    261                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,8); 
   \                     ??LPLD_CAN_SetBaudRate_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable19_22
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x00E9             LSLS     R1,R5,#+3
   \   00000064   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000068   0x1E40             SUBS     R0,R0,#+1
    262                  //设置CAN总线通信的波特率
    263                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(3)
    264                                   | CAN_CTRL1_RJW(0)   
    265                                   | CAN_CTRL1_PSEG1(0) 
    266                                   | CAN_CTRL1_PSEG2(1)
    267                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable19_23  ;; 0x10003
   \   00000070   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \   00000074   0x6061             STR      R1,[R4, #+4]
    268                  break;
   \   00000076   0xE01D             B.N      ??LPLD_CAN_SetBaudRate_5
    269                }
    270              case CAN_BAUD_RATE_33KBPS:
    271              case CAN_BAUD_RATE_83KBPS:
    272              case CAN_BAUD_RATE_100KBPS:
    273              case CAN_BAUD_RATE_125KBPS:
    274                {
    275                  //设置time_quanta = 12 
    276                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,12); 
   \                     ??LPLD_CAN_SetBaudRate_1: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable19_22
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0x200C             MOVS     R0,#+12
   \   00000080   0x4345             MULS     R5,R0,R5
   \   00000082   0xFBB1 0xF0F5      UDIV     R0,R1,R5
   \   00000086   0x1E40             SUBS     R0,R0,#+1
    277                  //设置CAN总线通信的波特率
    278                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(2) 
    279                                   | CAN_CTRL1_RJW(2)  
    280                                   | CAN_CTRL1_PSEG1(3) 
    281                                   | CAN_CTRL1_PSEG2(3)
    282                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable19_24  ;; 0x9b0002
   \   0000008E   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \   00000092   0x6061             STR      R1,[R4, #+4]
    283                  break;
   \   00000094   0xE00E             B.N      ??LPLD_CAN_SetBaudRate_5
    284                }
    285              case CAN_BAUD_RATE_50KBPS:
    286              case CAN_BAUD_RATE_500KBPS:
    287              case CAN_BAUD_RATE_250KBPS:
    288                {
    289                  //设置time_quanta = 12 
    290                  prescale = CAN_GET_PRESCALE(g_bus_clock,baud,12); 
   \                     ??LPLD_CAN_SetBaudRate_2: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable19_22
   \   0000009A   0x6801             LDR      R1,[R0, #+0]
   \   0000009C   0x200C             MOVS     R0,#+12
   \   0000009E   0x4345             MULS     R5,R0,R5
   \   000000A0   0xFBB1 0xF0F5      UDIV     R0,R1,R5
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
    291                  //设置CAN总线通信的波特率
    292                  canx->CTRL1 = (0 | CAN_CTRL1_PROPSEG(2)
    293                                   | CAN_CTRL1_RJW(1)  
    294                                   | CAN_CTRL1_PSEG1(3) 
    295                                   | CAN_CTRL1_PSEG2(3)
    296                                   | CAN_CTRL1_PRESDIV(prescale)); 
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable19_25  ;; 0x5b0002
   \   000000AC   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \   000000B0   0x6061             STR      R1,[R4, #+4]
    297                  break;
   \   000000B2   0xE7FF             B.N      ??LPLD_CAN_SetBaudRate_5
    298                }
    299              default:break;
    300            }
    301          }
   \                     ??LPLD_CAN_SetBaudRate_3: (+1)
   \                     ??LPLD_CAN_SetBaudRate_5: (+1)
   \   000000B4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    302          
    303          /*
    304           * LPLD_CAN_Deinit
    305           * CAN反初始化函数，在该函数中禁止CANx的总线时钟，禁止模块中断，关闭CAN模块
    306           * 
    307           * 参数:
    308           *    CAN_InitTypeDef--can_init_structure
    309           *                     具体定义见HW_CAN.h can_init_structure
    310           * 输出:
    311           *    无
    312           *
    313          */

   \                                 In section .text, align 2, keep-with-next
    314          void LPLD_CAN_Deinit(CAN_InitTypeDef can_init_structure)
    315          {
   \                     LPLD_CAN_Deinit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    316            CAN_Type *canx = can_init_structure.CAN_Canx;
   \   00000002   0x0004             MOVS     R4,R0
    317            
    318            if(canx == CAN0)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD10B             BNE.N    ??LPLD_CAN_Deinit_0
    319            {
    320              SIM->SCGC6 &= ~SIM_SCGC6_FLEXCAN0_MASK;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_6  ;; 0x4004803c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable19_6  ;; 0x4004803c
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    321              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000001C   0x201D             MOVS     R0,#+29
   \   0000001E   0x.... 0x....      BL       __NVIC_DisableIRQ
   \   00000022   0xE00A             B.N      ??LPLD_CAN_Deinit_1
    322            }
    323            else
    324            {
    325              SIM->SCGC3 &= ~SIM_SCGC3_FLEXCAN1_MASK;
   \                     ??LPLD_CAN_Deinit_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_7  ;; 0x40048030
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19_7  ;; 0x40048030
   \   00000032   0x6008             STR      R0,[R1, #+0]
    326              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   00000034   0x2025             MOVS     R0,#+37
   \   00000036   0x.... 0x....      BL       __NVIC_EnableIRQ
    327            }
    328            //禁止CAN外设
    329            canx->MCR |= CAN_MCR_MDIS_MASK;
   \                     ??LPLD_CAN_Deinit_1: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000040   0x6020             STR      R0,[R4, #+0]
    330            canx->MCR |= CAN_MCR_HALT_MASK; 
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000048   0x6020             STR      R0,[R4, #+0]
    331            canx->MCR |= CAN_MCR_FRZ_MASK;
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \   00000050   0x6020             STR      R0,[R4, #+0]
    332          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    333          /*
    334           * LPLD_CAN_EnableIrq
    335           * 使能CAN模块中断
    336           * 
    337           * 参数:
    338           *    CAN_InitTypeDef--can_init_structure
    339           *                     具体定义见HW_CAN.h can_init_structure
    340           * 输出:
    341           *    无
    342           *
    343          */

   \                                 In section .text, align 2, keep-with-next
    344          void LPLD_CAN_EnableIrq(CAN_InitTypeDef can_init_structure)
    345          {
   \                     LPLD_CAN_EnableIrq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    346            CAN_Type *canx = can_init_structure.CAN_Canx;
    347              
    348            if(canx == CAN0)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable19_5  ;; 0x40024000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD103             BNE.N    ??LPLD_CAN_EnableIrq_0
    349            {
    350              enable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000000A   0x201D             MOVS     R0,#+29
   \   0000000C   0x.... 0x....      BL       __NVIC_EnableIRQ
   \   00000010   0xE006             B.N      ??LPLD_CAN_EnableIrq_1
    351            }
    352            else if(canx == CAN1)
   \                     ??LPLD_CAN_EnableIrq_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable19_26  ;; 0x400a4000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD102             BNE.N    ??LPLD_CAN_EnableIrq_1
    353            {
    354              enable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       __NVIC_EnableIRQ
    355            }
    356          }
   \                     ??LPLD_CAN_EnableIrq_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    357          
    358          /*
    359           * LPLD_CAN_DisableIrq
    360           * 禁止CAN模块中断
    361           * 
    362           * 参数:
    363           *    CAN_InitTypeDef--can_init_structure
    364           *                     具体定义见HW_CAN.h can_init_structure
    365           * 输出:
    366           *    无
    367           *
    368          */

   \                                 In section .text, align 2, keep-with-next
    369          void LPLD_CAN_DisableIrq(CAN_InitTypeDef can_init_structure)
    370          {
   \                     LPLD_CAN_DisableIrq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    371            CAN_Type *canx = can_init_structure.CAN_Canx;
    372              
    373            if(canx == CAN0)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable19_5  ;; 0x40024000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD103             BNE.N    ??LPLD_CAN_DisableIrq_0
    374            {
    375              disable_irq(CAN0_ORed_Message_buffer_IRQn);
   \   0000000A   0x201D             MOVS     R0,#+29
   \   0000000C   0x.... 0x....      BL       __NVIC_DisableIRQ
   \   00000010   0xE006             B.N      ??LPLD_CAN_DisableIrq_1
    376            }
    377            else if(canx == CAN1)
   \                     ??LPLD_CAN_DisableIrq_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable19_26  ;; 0x400a4000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD102             BNE.N    ??LPLD_CAN_DisableIrq_1
    378            {
    379              disable_irq(CAN1_ORed_Message_buffer_IRQn);
   \   0000001A   0x2025             MOVS     R0,#+37
   \   0000001C   0x.... 0x....      BL       __NVIC_DisableIRQ
    380            }
    381          }
   \                     ??LPLD_CAN_DisableIrq_1: (+1)
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    382          
    383          /*
    384           * LPLD_CAN_InitMessageObject
    385           *
    386           * 设置CAN Message buffer（Msg）格式，通过CAN_MSGOBJ_InitTypeDef
    387           * 结构体对CAN Message buffer进行初始化。
    388           * 
    389           * 参数:
    390           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    391           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    392           *    message_id
    393           *      设置message_id，id长度根据CAN_MSGOBJ_InitTypeDef的参数而定
    394           *      id的长度分为11位标准帧和29位扩展帧两种
    395           *      CAN_MSGOBJ_ID_STD 表示标准帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_STD
    396           *      此时message_id最长为11位，不能超过0x0FFF；
    397           *      CAN_MSGOBJ_ID_EXT 表示扩展帧，如CAN_MSGOBJ_InitTypeDef中设置id长度为CAN_MSGOBJ_ID_EXT
    398           *      此时message_id最长为29位，不能超过0x1FFFFFFF；
    399           * 输出:
    400           *    无
    401           *
    402           */

   \                                 In section .text, align 2, keep-with-next
    403          void LPLD_CAN_InitMessageObject(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,uint32 rx_id)
    404          { 
   \                     LPLD_CAN_InitMessageObject: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
    405            uint8     msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \   00000002   0xF89D 0x4004      LDRB     R4,[SP, #+4]
    406            uint8     dir           = can_msg_init_structure.CAN_MsgDirection;
   \   00000006   0xF89D 0x1008      LDRB     R1,[SP, #+8]
    407            CAN_Type *canx_ptr      = can_msg_init_structure.CAN_Canx;
   \   0000000A   0x9D00             LDR      R5,[SP, #+0]
    408            uint32    id_type       = can_msg_init_structure.CAN_MsgIdLength;
   \   0000000C   0xF89D 0x0005      LDRB     R0,[SP, #+5]
    409            uint32    cs_temp = CAN_MB_CS_CODE(CAN_MSGOBJ_RX_EMPTY);
   \   00000010   0xF05F 0x6280      MOVS     R2,#+67108864
    410            CAN_ISR_CALLBACK isr_func = can_msg_init_structure.CAN_Isr;
   \   00000014   0x9E03             LDR      R6,[SP, #+12]
    411            uint32    id_temp;	
    412            
    413            if(dir == CAN_MSGOBJ_DIR_RX)
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD11E             BNE.N    ??LPLD_CAN_InitMessageObject_0
    414            {
    415              canx_ptr->MB[msg_num_temp].CS = CAN_MB_CS_CODE(CAN_MSGOBJ_RX_INACTIVE); 
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x0123             LSLS     R3,R4,#+4
   \   00000022   0x442B             ADD      R3,R5,R3
   \   00000024   0xF8C3 0x1080      STR      R1,[R3, #+128]
    416              //设置Msg的ID
    417              if(id_type == CAN_MSGOBJ_ID_STD)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD105             BNE.N    ??LPLD_CAN_InitMessageObject_1
    418              {
    419                id_temp =  CAN_MB_ID_STD(rx_id);
   \   0000002C   0x9B08             LDR      R3,[SP, #+32]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable19_27  ;; 0x1ffc0000
   \   00000032   0xEA11 0x4183      ANDS     R1,R1,R3, LSL #+18
   \   00000036   0xE002             B.N      ??LPLD_CAN_InitMessageObject_2
    420              }
    421              else
    422              {
    423                id_temp =  CAN_MB_ID_EXT(rx_id);
   \                     ??LPLD_CAN_InitMessageObject_1: (+1)
   \   00000038   0x9908             LDR      R1,[SP, #+32]
   \   0000003A   0xF021 0x4160      BIC      R1,R1,#0xE0000000
    424              }
    425              canx_ptr->MB[msg_num_temp].ID = id_temp;  
   \                     ??LPLD_CAN_InitMessageObject_2: (+1)
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x0123             LSLS     R3,R4,#+4
   \   00000042   0x442B             ADD      R3,R5,R3
   \   00000044   0xF8C3 0x1084      STR      R1,[R3, #+132]
    426              canx_ptr->MB[msg_num_temp].CS = cs_temp | CAN_MB_CS_IDE(id_type);
   \   00000048   0x0540             LSLS     R0,R0,#+21
   \   0000004A   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   0000004E   0x4310             ORRS     R0,R0,R2
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x0121             LSLS     R1,R4,#+4
   \   00000054   0x4429             ADD      R1,R5,R1
   \   00000056   0xF8C1 0x0080      STR      R0,[R1, #+128]
    427            }
    428            if(can_msg_init_structure.CAN_MsgInterrupt == TRUE)
   \                     ??LPLD_CAN_InitMessageObject_0: (+1)
   \   0000005A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD11A             BNE.N    ??LPLD_CAN_InitMessageObject_3
    429            {
    430              LPLD_CAN_EnableMsgInterrupt(canx_ptr,msg_num_temp);//使能Msg中断 
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       LPLD_CAN_EnableMsgInterrupt
    431              //设置Msg中断回掉函数
    432              if(canx_ptr == CAN0)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD108             BNE.N    ??LPLD_CAN_InitMessageObject_4
    433              {
    434                if(isr_func != NULL)
   \   00000074   0x0030             MOVS     R0,R6
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD01F             BEQ.N    ??LPLD_CAN_InitMessageObject_5
    435                {
    436                  CAN0_ISR[msg_num_temp] = isr_func;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable19_28
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
   \   00000084   0xE019             B.N      ??LPLD_CAN_InitMessageObject_5
    437                }
    438              }
    439              else
    440              {
    441                if(isr_func != NULL)
   \                     ??LPLD_CAN_InitMessageObject_4: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD016             BEQ.N    ??LPLD_CAN_InitMessageObject_5
    442                {
    443                  CAN1_ISR[msg_num_temp] = isr_func;
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable19_29
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF840 0x6024      STR      R6,[R0, R4, LSL #+2]
   \   00000096   0xE010             B.N      ??LPLD_CAN_InitMessageObject_5
    444                }
    445              }
    446            }
    447            else
    448            {
    449              if(canx_ptr == CAN0)
   \                     ??LPLD_CAN_InitMessageObject_3: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable19_5  ;; 0x40024000
   \   0000009C   0x4285             CMP      R5,R0
   \   0000009E   0xD106             BNE.N    ??LPLD_CAN_InitMessageObject_6
    450              {
    451                  CAN0_ISR[msg_num_temp] = NULL; 
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable19_28
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   000000AC   0xE005             B.N      ??LPLD_CAN_InitMessageObject_5
    452              }
    453              else
    454              {
    455                  CAN1_ISR[msg_num_temp] = NULL;
   \                     ??LPLD_CAN_InitMessageObject_6: (+1)
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable19_29
   \   000000B4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B6   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
    456              }
    457            }
    458          }
   \                     ??LPLD_CAN_InitMessageObject_5: (+1)
   \   000000BA   0xBD7F             POP      {R0-R6,PC}       ;; return
    459          /*
    460           * LPLD_CAN_TransmitMessage
    461           * CAN 发送消息函数
    462           * 参数:
    463           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    464           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    465           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    466           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    467           *    该结构体用于定义CAN的消息格式，当CAN发送消息时，会从CAN_MessageFormat_TypeDef定义的结构体对象中
    468           *    提取信息并存储到MSG中，MSG会将消息发送到CAN总线上。
    469           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    470           * 输出:
    471           *    1 发送完毕
    472           *    0 发送失败
    473           *
    474           */

   \                                 In section .text, align 2, keep-with-next
    475          uint8 LPLD_CAN_TransmitMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,
    476                                         CAN_MessageFormat_TypeDef *can_tx_msg )
    477          {
   \                     LPLD_CAN_TransmitMessage: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x980E             LDR      R0,[SP, #+56]
    478            uint8  request;
    479            uint8  msg_num_temp  = can_msg_init_structure.CAN_MsgNum;
   \   00000008   0xF89D 0x6008      LDRB     R6,[SP, #+8]
    480            CAN_Type *canx_ptr   = can_msg_init_structure.CAN_Canx;
   \   0000000C   0x9F01             LDR      R7,[SP, #+4]
    481            uint32  id_type      = can_msg_init_structure.CAN_MsgIdLength;
   \   0000000E   0xF89D 0x4009      LDRB     R4,[SP, #+9]
    482            
    483            uint32  message_id = can_tx_msg->CAN_MsgID; ;
   \   00000012   0x6805             LDR      R5,[R0, #+0]
    484            uint8   priority = can_tx_msg->CAN_MsgPriority; 
   \   00000014   0xF890 0x800F      LDRB     R8,[R0, #+15]
    485            uint8  *in_data_buffer = can_tx_msg->CAN_MsgDataBuffer;
   \   00000018   0xF110 0x0906      ADDS     R9,R0,#+6
    486            uint8   in_data_length = can_tx_msg->CAN_MsgDataLength;
   \   0000001C   0xF890 0xA00E      LDRB     R10,[R0, #+14]
    487            uint32  id_temp;
    488            uint32  cs_temp = CAN_MB_CS_RTR(can_msg_init_structure.CAN_MsgRTR) | 
    489                              CAN_MB_CS_SRR(can_msg_init_structure.CAN_MsgSRR) |
    490                              CAN_MB_CS_IDE(can_msg_init_structure.CAN_MsgIdLength);
   \   00000020   0xF89D 0xB00B      LDRB     R11,[SP, #+11]
   \   00000024   0xEA5F 0x5B0B      LSLS     R11,R11,#+20
   \   00000028   0xF41B 0x1B80      ANDS     R11,R11,#0x100000
   \   0000002C   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000030   0x0580             LSLS     R0,R0,#+22
   \   00000032   0xF410 0x0080      ANDS     R0,R0,#0x400000
   \   00000036   0xEA50 0x0B0B      ORRS     R11,R0,R11
   \   0000003A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000003E   0x0540             LSLS     R0,R0,#+21
   \   00000040   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   00000044   0xEA50 0x0B0B      ORRS     R11,R0,R11
    491            
    492            if(msg_num_temp >= MSG_MAX_NO || in_data_length > 8)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0x2E10             CMP      R6,#+16
   \   0000004C   0xDA04             BGE.N    ??LPLD_CAN_TransmitMessage_0
   \   0000004E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000052   0xF1BA 0x0F09      CMP      R10,#+9
   \   00000056   0xDB01             BLT.N    ??LPLD_CAN_TransmitMessage_1
    493            {
    494              return 0; // 超出阈值
   \                     ??LPLD_CAN_TransmitMessage_0: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE041             B.N      ??LPLD_CAN_TransmitMessage_2
    495            }
    496            //如果发送Msg缓冲区中的CODE不等于CAN_MSGOBJ_TX_ONCE
    497            if( LPLD_CAN_GetMsgCode(canx_ptr,msg_num_temp) != CAN_MSGOBJ_TX_ONCE)
   \                     ??LPLD_CAN_TransmitMessage_1: (+1)
   \   0000005C   0x0031             MOVS     R1,R6
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x0038             MOVS     R0,R7
   \   00000062   0x.... 0x....      BL       LPLD_CAN_GetMsgCode
   \   00000066   0x280C             CMP      R0,#+12
   \   00000068   0xD038             BEQ.N    ??LPLD_CAN_TransmitMessage_3
    498            {
    499              //设置Msg的ID
    500              if(id_type == CAN_MSGOBJ_ID_STD)
   \   0000006A   0x2C00             CMP      R4,#+0
   \   0000006C   0xD104             BNE.N    ??LPLD_CAN_TransmitMessage_4
    501              {
    502                id_temp =  CAN_MB_ID_STD(message_id);
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable19_27  ;; 0x1ffc0000
   \   00000072   0xEA10 0x4085      ANDS     R0,R0,R5, LSL #+18
   \   00000076   0xE001             B.N      ??LPLD_CAN_TransmitMessage_5
    503              }
    504              else
    505              {
    506                id_temp =  CAN_MB_ID_EXT(message_id);
   \                     ??LPLD_CAN_TransmitMessage_4: (+1)
   \   00000078   0xF025 0x4060      BIC      R0,R5,#0xE0000000
    507              }
    508              //向发送Msg缓冲区中的CODE中写INACTIVE命令
    509              canx_ptr->MB[msg_num_temp].CS = CAN_MB_CS_CODE(CAN_MSGOBJ_TX_INACTIVE) | cs_temp;
   \                     ??LPLD_CAN_TransmitMessage_5: (+1)
   \   0000007C   0xF05B 0x6B00      ORRS     R11,R11,#0x8000000
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0x0131             LSLS     R1,R6,#+4
   \   00000084   0x4439             ADD      R1,R7,R1
   \   00000086   0xF8C1 0xB080      STR      R11,[R1, #+128]
    510              canx_ptr->MB[msg_num_temp].ID = CAN_MB_ID_PRIO(priority) | id_temp;
   \   0000008A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000008E   0xEA50 0x7048      ORRS     R0,R0,R8, LSL #+29
   \   00000092   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000094   0x0131             LSLS     R1,R6,#+4
   \   00000096   0x4439             ADD      R1,R7,R1
   \   00000098   0xF8C1 0x0084      STR      R0,[R1, #+132]
    511              //向Msg中写入要发送的数据
    512              LPLD_CAN_WriteData(canx_ptr,msg_num_temp,in_data_length,in_data_buffer);
   \   0000009C   0x464B             MOV      R3,R9
   \   0000009E   0x4652             MOV      R2,R10
   \   000000A0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   0x0031             MOVS     R1,R6
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0x0038             MOVS     R0,R7
   \   000000A8   0x.... 0x....      BL       LPLD_CAN_WriteData
    513              //向发送Msg缓冲区中的CODE中写TX_ONCE命令，等待发送完成
    514              canx_ptr->MB[msg_num_temp].CS = (canx_ptr->MB[msg_num_temp].CS & (~CAN_MB_CS_CODE_MASK)) | 
    515                                               CAN_MB_CS_CODE(CAN_MSGOBJ_TX_ONCE)|
    516                                               CAN_MB_CS_DLC(in_data_length);
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0x0130             LSLS     R0,R6,#+4
   \   000000B0   0x4438             ADD      R0,R7,R0
   \   000000B2   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   000000B6   0xF030 0x6070      BICS     R0,R0,#0xF000000
   \   000000BA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000BE   0xEA5F 0x4A0A      LSLS     R10,R10,#+16
   \   000000C2   0xF41A 0x2A70      ANDS     R10,R10,#0xF0000
   \   000000C6   0xEA5A 0x0A00      ORRS     R10,R10,R0
   \   000000CA   0xF05A 0x6A40      ORRS     R10,R10,#0xC000000
   \   000000CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D0   0x0130             LSLS     R0,R6,#+4
   \   000000D2   0x4438             ADD      R0,R7,R0
   \   000000D4   0xF8C0 0xA080      STR      R10,[R0, #+128]
    517              //如果开启发送中断，发送完毕后会触发中断
    518              request = 1;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE000             B.N      ??LPLD_CAN_TransmitMessage_6
    519            }
    520            else
    521            {
    522              request = 0;
   \                     ??LPLD_CAN_TransmitMessage_3: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
    523            }
    524            return (request);
   \                     ??LPLD_CAN_TransmitMessage_6: (+1)
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??LPLD_CAN_TransmitMessage_2: (+1)
   \   000000E0   0xB005             ADD      SP,SP,#+20
   \   000000E2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    525          }
    526          
    527          /*
    528           * LPLD_CAN_ReceivedMessage
    529           * CAN 处理接收函数，此函数一般在CAN中断函数中调用
    530           * 参数:
    531           *    CAN_MSGOBJ_InitTypeDef--can_msg_init_structure
    532           *                            具体定义见HW_CAN.h CAN_MSGOBJ_InitTypeDef
    533           *    CAN_MessageFormat_TypeDef--*can_rx_msg
    534           *                            具体定义见HW_CAN.h CAN_MessageFormat_TypeDef
    535           *    该结构体用于定义CAN的消息格式，当CAN成功接收消息以后，会从MSG中将信息存储到
    536           *    CAN_MessageFormat_TypeDef定义的结构体对象中。
    537           *    该结构体中的主要变量为 消息ID、时间戳、数据长度、存储数据的缓冲区
    538           *    
    539           *  输出：
    540           *    无
    541           */

   \                                 In section .text, align 2, keep-with-next
    542          void LPLD_CAN_ReceivedMessage(CAN_MSGOBJ_InitTypeDef can_msg_init_structure,\
    543                                        CAN_MessageFormat_TypeDef *can_rx_msg)
    544          {
   \                     LPLD_CAN_ReceivedMessage: (+1)
   \   00000000   0xB5FF             PUSH     {R0-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    545            uint32 message_code,i;
    546            volatile uint16 timer;
    547            uint8 rx_data[CAN_DATA_MAX_BYTES];
    548            uint8 data_length;
    549            uint16 time_stamp;
    550            uint32 msg_id;
    551            CAN_Type *canx = can_msg_init_structure.CAN_Canx;
   \   00000004   0x9C03             LDR      R4,[SP, #+12]
    552            uint8 msg_num = can_msg_init_structure.CAN_MsgNum;
   \   00000006   0xF89D 0x5010      LDRB     R5,[SP, #+16]
    553            //获得Msg缓冲区中的code值
    554            message_code = LPLD_CAN_GetMsgCode(canx,msg_num);
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       LPLD_CAN_GetMsgCode
    555            
    556            if ((message_code != CAN_MSGOBJ_RX_BUSY) && 
    557               (message_code != CAN_MSGOBJ_RX_OVERRUN))
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD041             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xD03F             BEQ.N    ??LPLD_CAN_ReceivedMessage_0
    558            {
    559              //读取ID(可选)
    560              msg_id = LPLD_CAN_GetMsgID(canx, msg_num);
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       LPLD_CAN_GetMsgID
   \   00000026   0x0007             MOVS     R7,R0
    561             
    562              //读取Msg缓冲区接收数据的长度
    563              data_length    = (uint8_t)LPLD_CAN_GetMsgLength(canx, msg_num);
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       LPLD_CAN_GetMsgLength
   \   00000032   0x0006             MOVS     R6,R0
    564              //读取Msg缓冲区接收数据
    565              LPLD_CAN_GetData(canx, msg_num,data_length,rx_data);
   \   00000034   0xAB01             ADD      R3,SP,#+4
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       LPLD_CAN_GetData
    566              //获得Msg缓冲区时间戳
    567              time_stamp = LPLD_CAN_GetMsgTimeStamp(canx, msg_num);
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       LPLD_CAN_GetMsgTimeStamp
    568              
    569              for(i = data_length; i < 8; i++)
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0xE003             B.N      ??LPLD_CAN_ReceivedMessage_1
    570              {
    571                 rx_data[i] = 0;
   \                     ??LPLD_CAN_ReceivedMessage_2: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0xAB01             ADD      R3,SP,#+4
   \   00000058   0x545A             STRB     R2,[R3, R1]
    572              }
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??LPLD_CAN_ReceivedMessage_1: (+1)
   \   0000005C   0x2908             CMP      R1,#+8
   \   0000005E   0xD3F9             BCC.N    ??LPLD_CAN_ReceivedMessage_2
    573              //将MSG中的消息存储到can_rx_msg中
    574              can_rx_msg->CAN_MsgID = msg_id;
   \   00000060   0x990C             LDR      R1,[SP, #+48]
   \   00000062   0x600F             STR      R7,[R1, #+0]
    575              can_rx_msg->CAN_MsgDataLength = data_length;
   \   00000064   0x990C             LDR      R1,[SP, #+48]
   \   00000066   0x738E             STRB     R6,[R1, #+14]
    576              can_rx_msg->CAN_MsgTimeStamp  = time_stamp;
   \   00000068   0x990C             LDR      R1,[SP, #+48]
   \   0000006A   0x8088             STRH     R0,[R1, #+4]
    577              memcpy(can_rx_msg->CAN_MsgDataBuffer,rx_data,data_length);
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x0032             MOVS     R2,R6
   \   00000070   0xA901             ADD      R1,SP,#+4
   \   00000072   0x980C             LDR      R0,[SP, #+48]
   \   00000074   0x1D80             ADDS     R0,R0,#+6
   \   00000076   0x.... 0x....      BL       memcpy
    578               
    579              //读取自由计数器，解锁当前Msg缓冲区
    580              timer = LPLD_CAN_UnlockMsg(canx);
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       LPLD_CAN_UnlockMsg
   \   00000080   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    581              //清空Msg缓冲区的中断标志位
    582              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \   00000084   0x0029             MOVS     R1,R5
   \   00000086   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
    583              //再次写邮箱的code为empty状态
    584              LPLD_CAN_SetMsgCode(canx,msg_num,CAN_MSGOBJ_RX_EMPTY);
   \   0000008E   0x2204             MOVS     R2,#+4
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       LPLD_CAN_SetMsgCode
   \   0000009A   0xE009             B.N      ??LPLD_CAN_ReceivedMessage_3
    585            }
    586            else
    587            {
    588              //接收邮箱溢出
    589              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_ReceivedMessage_0: (+1)
   \   0000009C   0x0029             MOVS     R1,R5
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
    590              //读取自由计数器，解锁当前Msg缓冲区
    591              timer = LPLD_CAN_UnlockMsg(canx);
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       LPLD_CAN_UnlockMsg
   \   000000AC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    592            }
    593          }
   \                     ??LPLD_CAN_ReceivedMessage_3: (+1)
   \   000000B0   0xB007             ADD      SP,SP,#+28
   \   000000B2   0xBDF0             POP      {R4-R7,PC}       ;; return
    594          
    595          /*
    596           * LPLD_CAN_Interrupt_ClearPending
    597           * 清除Msg的中断标志位
    598           * 参数:
    599           *    CAN_Type *canx
    600           *      |___ CAN0 --CAN0号模块
    601           *      |___ CAN1 --CAN1号模块
    602           *    msg_num 选择要清除中断标志的Msg缓冲区
    603           *      |___ MSG_NUM_0 --Msg缓冲区0
    604           *      |___ MSG_NUM_1 --Msg缓冲区1
    605           *      |___ MSG_NUM_2 --Msg缓冲区2
    606           *      |___ MSG_NUM_3 --Msg缓冲区3
    607           *      |___ MSG_NUM_4 --Msg缓冲区4
    608           *      ...... 
    609           *      |___ MSG_NUM_15 --Msg缓冲区15
    610           * 输出:
    611           *   无
    612           */

   \                                 In section .text, align 2, keep-with-next
    613          static void LPLD_CAN_Interrupt_ClearPending(CAN_Type *canx, uint8 msg_num)
    614          {   
    615            if(msg_num < 32)
   \                     LPLD_CAN_Interrupt_ClearPending: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA06             BGE.N    ??LPLD_CAN_Interrupt_ClearPending_0
    616            {
    617              canx->IFLAG1 |= (1<<msg_num); 
   \   00000006   0x6B02             LDR      R2,[R0, #+48]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000000E   0x4311             ORRS     R1,R1,R2
   \   00000010   0x6301             STR      R1,[R0, #+48]
   \   00000012   0xE005             B.N      ??LPLD_CAN_Interrupt_ClearPending_1
    618            }
    619            else
    620            {
    621              canx->IFLAG2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_Interrupt_ClearPending_0: (+1)
   \   00000014   0x6AC2             LDR      R2,[R0, #+44]
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x3920             SUBS     R1,R1,#+32
   \   0000001A   0x408B             LSLS     R3,R3,R1
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x62C2             STR      R2,[R0, #+44]
    622            }
    623          }
   \                     ??LPLD_CAN_Interrupt_ClearPending_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    624          
    625          /*
    626           * LPLD_CAN_Interrupt_GetFlag
    627           * 获得CAN 的中断标志位
    628           * 参数:
    629           *    CAN_Type *canx
    630           *      |___ CAN0 --CAN0号模块
    631           *      |___ CAN1 --CAN1号模块
    632           *    msg_num 选择要获得中断标志的Msg缓冲区
    633           *      |___ MSG_NUM_0 --Msg缓冲区0
    634           *      |___ MSG_NUM_1 --Msg缓冲区1
    635           *      |___ MSG_NUM_2 --Msg缓冲区2
    636           *      |___ MSG_NUM_3 --Msg缓冲区3
    637           *      |___ MSG_NUM_4 --Msg缓冲区4
    638           *      ...... 
    639           *      |___ MSG_NUM_15 --Msg缓冲区15
    640           * 输出:
    641           *    返回需要 Msg缓冲区的中断标志位
    642           */

   \                                 In section .text, align 2, keep-with-next
    643          static uint8 LPLD_CAN_Interrupt_GetFlag(CAN_Type *canx, uint8 msg_num)
    644          {   
    645            uint8 status;
    646            if(msg_num < 32)
   \                     LPLD_CAN_Interrupt_GetFlag: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA04             BGE.N    ??LPLD_CAN_Interrupt_GetFlag_0
    647            {
    648              status = (canx->IFLAG1 >> msg_num) & 0x01; 
   \   00000006   0x6B00             LDR      R0,[R0, #+48]
   \   00000008   0x40C8             LSRS     R0,R0,R1
   \   0000000A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000E   0xE004             B.N      ??LPLD_CAN_Interrupt_GetFlag_1
    649            }
    650            else
    651            {
    652              status = (canx->IFLAG2 >> (msg_num - 32) )& 0x01; 
   \                     ??LPLD_CAN_Interrupt_GetFlag_0: (+1)
   \   00000010   0x6AC0             LDR      R0,[R0, #+44]
   \   00000012   0x3920             SUBS     R1,R1,#+32
   \   00000014   0x40C8             LSRS     R0,R0,R1
   \   00000016   0xF010 0x0001      ANDS     R0,R0,#0x1
    653            }
    654            return status;
   \                     ??LPLD_CAN_Interrupt_GetFlag_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
    655          }
    656          
    657          /*
    658           * LPLD_CAN_UnlockMsg
    659           * 该函数通过读取自由计数器，解锁Msg
    660           * 参数:
    661           *    canx--设置CAN总线通道
    662           *      |__CAN0 --CAN0号模块
    663           *      |__CAN1 --CAN1号模块
    664           * 输出:
    665           *    16位CAN自由计数器记录的时间戳
    666           */

   \                                 In section .text, align 2, keep-with-next
    667          static uint16 LPLD_CAN_UnlockMsg(CAN_Type *canx)
    668          {
    669            return (canx->TIMER);
   \                     LPLD_CAN_UnlockMsg: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    670          }
    671          
    672          /*
    673           * LPLD_CAN_EnableMsgInterrupt
    674           * 该函数用于使能Msg中断
    675           * 
    676           * 参数:
    677           *    canx--设置CAN总线通道
    678           *      |__CAN0 --CAN0号模块
    679           *      |__CAN1 --CAN1号模块
    680           *    msg_num 选择需要使能中断的Msg缓冲区
    681           *      |___ MSG_NUM_0 --Msg缓冲区0
    682           *      |___ MSG_NUM_1 --Msg缓冲区1
    683           *      |___ MSG_NUM_2 --Msg缓冲区2
    684           *      |___ MSG_NUM_3 --Msg缓冲区3
    685           *      |___ MSG_NUM_4 --Msg缓冲区4
    686           *      ...... 
    687           *      |___ MSG_NUM_15 --Msg缓冲区15
    688           * 输出:
    689           *    无
    690           *
    691           */

   \                                 In section .text, align 2, keep-with-next
    692          static void LPLD_CAN_EnableMsgInterrupt(CAN_Type *canx, uint8 msg_num)
    693          {
    694            if(msg_num < 32)
   \                     LPLD_CAN_EnableMsgInterrupt: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2920             CMP      R1,#+32
   \   00000004   0xDA06             BGE.N    ??LPLD_CAN_EnableMsgInterrupt_0
    695            {
    696              canx->IMASK1 |= (1<<msg_num); 
   \   00000006   0x6A82             LDR      R2,[R0, #+40]
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000000E   0x4311             ORRS     R1,R1,R2
   \   00000010   0x6281             STR      R1,[R0, #+40]
   \   00000012   0xE005             B.N      ??LPLD_CAN_EnableMsgInterrupt_1
    697            }
    698            else
    699            {
    700              canx->IMASK2 |= (1<<(msg_num-32));
   \                     ??LPLD_CAN_EnableMsgInterrupt_0: (+1)
   \   00000014   0x6A42             LDR      R2,[R0, #+36]
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x3920             SUBS     R1,R1,#+32
   \   0000001A   0x408B             LSLS     R3,R3,R1
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x6242             STR      R2,[R0, #+36]
    701            }
    702          }
   \                     ??LPLD_CAN_EnableMsgInterrupt_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    703          
    704          /*
    705           * LPLD_CAN_SetMsgCode
    706           * 该函数用于设置Msg的code值
    707           * 
    708           * 参数:
    709           *    canx--设置CAN总线通道
    710           *      |__CAN0 --CAN0号模块
    711           *      |__CAN1 --CAN1号模块
    712           *    msg_num 选择需要设置CODE的Msg缓冲区
    713           *      |___ MSG_NUM_0 --Msg缓冲区0
    714           *      |___ MSG_NUM_1 --Msg缓冲区1
    715           *      |___ MSG_NUM_2 --Msg缓冲区2
    716           *      |___ MSG_NUM_3 --Msg缓冲区3
    717           *      |___ MSG_NUM_4 --Msg缓冲区4
    718           *      ...... 
    719           *      |___ MSG_NUM_15 --Msg缓冲区15
    720           *    code--需要设置的code值
    721           * 输出:
    722           *    无
    723           *
    724           */

   \                                 In section .text, align 2, keep-with-next
    725          static void LPLD_CAN_SetMsgCode(CAN_Type *canx, uint8 msg_num, uint8 code)
    726          {
    727            //canx->MB[msg_num].CS &= (~CAN_MB_CS_CODE_MASK);
    728            canx->MB[msg_num].CS |= CAN_MB_CS_CODE(code);
   \                     LPLD_CAN_SetMsgCode: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x010B             LSLS     R3,R1,#+4
   \   00000004   0x4403             ADD      R3,R0,R3
   \   00000006   0xF8D3 0x3080      LDR      R3,[R3, #+128]
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0612             LSLS     R2,R2,#+24
   \   0000000E   0xF012 0x6270      ANDS     R2,R2,#0xF000000
   \   00000012   0x431A             ORRS     R2,R2,R3
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0109             LSLS     R1,R1,#+4
   \   00000018   0x4408             ADD      R0,R0,R1
   \   0000001A   0xF8C0 0x2080      STR      R2,[R0, #+128]
    729          }
   \   0000001E   0x4770             BX       LR               ;; return
    730          
    731          /*
    732           * LPLD_CAN_GetMsgCode
    733           * 该函数用于获得Msg缓冲区的code值
    734           * 
    735           * 参数:
    736           *    canx--设置CAN总线通道
    737           *      |__CAN0 --CAN0号模块
    738           *      |__CAN1 --CAN1号模块
    739           *    msg_num 选择需要获得CODE的Msg缓冲区
    740           *      |___ MSG_NUM_0 --Msg缓冲区0
    741           *      |___ MSG_NUM_1 --Msg缓冲区1
    742           *      |___ MSG_NUM_2 --Msg缓冲区2
    743           *      |___ MSG_NUM_3 --Msg缓冲区3
    744           *      |___ MSG_NUM_4 --Msg缓冲区4
    745           *      ...... 
    746           *      |___ MSG_NUM_15 --Msg缓冲区15
    747           * 输出:
    748           *     返回相应Msg缓冲区的code
    749           *
    750           */

   \                                 In section .text, align 2, keep-with-next
    751          static uint32 LPLD_CAN_GetMsgCode(CAN_Type *canx, uint8 msg_num)
    752          {
    753             return CAN_GET_MB_CS_CODE(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgCode: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x0109             LSLS     R1,R1,#+4
   \   00000004   0x4408             ADD      R0,R0,R1
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0xF3C0 0x6003      UBFX     R0,R0,#+24,#+4
   \   0000000E   0x4770             BX       LR               ;; return
    754          }
    755          /*
    756           * LPLD_CAN_GetMsgTimeStamp
    757           * 该函数用于获得Msg缓冲区的时间戳
    758           * 
    759           * 参数:
    760           *    canx--设置CAN总线通道
    761           *      |__CAN0 --CAN0号模块
    762           *      |__CAN1 --CAN1号模块
    763           *    msg_num 选择需要获得时间戳的Msg缓冲区
    764           *      |___ MSG_NUM_0 --Msg缓冲区0
    765           *      |___ MSG_NUM_1 --Msg缓冲区1
    766           *      |___ MSG_NUM_2 --Msg缓冲区2
    767           *      |___ MSG_NUM_3 --Msg缓冲区3
    768           *      |___ MSG_NUM_4 --Msg缓冲区4
    769           *      ...... 
    770           *      |___ MSG_NUM_15 --Msg缓冲区15
    771           * 输出:
    772           *     返回相应Msg缓冲区的时间戳
    773           *
    774           */

   \                                 In section .text, align 2, keep-with-next
    775          static uint16 LPLD_CAN_GetMsgTimeStamp(CAN_Type *canx, uint8 msg_num)
    776          {
    777            return CAN_GET_MB_CS_TIMESTAMP(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgTimeStamp: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x0109             LSLS     R1,R1,#+4
   \   00000004   0x4408             ADD      R0,R0,R1
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    778          }
    779          /*
    780           * LPLD_CAN_GetMsgID
    781           * 该函数用于获得Msg缓冲区的ID值
    782           * 
    783           * 参数:
    784           *    canx--设置CAN总线通道
    785           *      |__CAN0 --CAN0号模块
    786           *      |__CAN1 --CAN1号模块
    787           *    msg_num 选择需要获得ID的Msg缓冲区
    788           *      |___ MSG_NUM_0 --Msg缓冲区0
    789           *      |___ MSG_NUM_1 --Msg缓冲区1
    790           *      |___ MSG_NUM_2 --Msg缓冲区2
    791           *      |___ MSG_NUM_3 --Msg缓冲区3
    792           *      |___ MSG_NUM_4 --Msg缓冲区4
    793           *      ...... 
    794           *      |___ MSG_NUM_15 --Msg缓冲区15
    795           * 输出:
    796           *     返回相应Msg缓冲区的ID
    797           *
    798           */

   \                                 In section .text, align 2, keep-with-next
    799          static uint32 LPLD_CAN_GetMsgID(CAN_Type *canx, uint8 msg_num)
    800          {
    801            uint32 id_temp;
    802            if(CAN_GET_MB_CS_IDE(canx->MB[msg_num].CS) == CAN_MSGOBJ_ID_STD)
   \                     LPLD_CAN_GetMsgID: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x010A             LSLS     R2,R1,#+4
   \   00000004   0x4402             ADD      R2,R0,R2
   \   00000006   0xF8D2 0x2080      LDR      R2,[R2, #+128]
   \   0000000A   0xF3C2 0x5240      UBFX     R2,R2,#+21,#+1
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD107             BNE.N    ??LPLD_CAN_GetMsgID_0
    803            {
    804              id_temp =  CAN_GET_MB_ID_STD(canx->MB[msg_num].ID);
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x0109             LSLS     R1,R1,#+4
   \   00000016   0x4408             ADD      R0,R0,R1
   \   00000018   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000001C   0xF3C0 0x408A      UBFX     R0,R0,#+18,#+11
   \   00000020   0xE006             B.N      ??LPLD_CAN_GetMsgID_1
    805            }
    806            else
    807            {
    808              id_temp =  CAN_GET_MB_ID_EXT(canx->MB[msg_num].ID);
   \                     ??LPLD_CAN_GetMsgID_0: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x0109             LSLS     R1,R1,#+4
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000002C   0xF020 0x4060      BIC      R0,R0,#0xE0000000
    809            }
    810            return id_temp;
   \                     ??LPLD_CAN_GetMsgID_1: (+1)
   \   00000030   0x4770             BX       LR               ;; return
    811          }
    812          /*
    813           * LPLD_CAN_GetMsgLength
    814           * 该函数用于获得Msg缓冲区的数据长度
    815           * 
    816           * 参数:
    817           *    canx--设置CAN总线通道
    818           *      |__CAN0 --CAN0号模块
    819           *      |__CAN1 --CAN1号模块
    820           *    msg_num 选择需要获得数据长度的Msg缓冲区
    821           *      |___ MSG_NUM_0 --Msg缓冲区0
    822           *      |___ MSG_NUM_1 --Msg缓冲区1
    823           *      |___ MSG_NUM_2 --Msg缓冲区2
    824           *      |___ MSG_NUM_3 --Msg缓冲区3
    825           *      |___ MSG_NUM_4 --Msg缓冲区4
    826           *      ...... 
    827           *      |___ MSG_NUM_15 --Msg缓冲区15
    828           * 输出:
    829           *     数据的长度
    830           *
    831           */

   \                                 In section .text, align 2, keep-with-next
    832          static uint8 LPLD_CAN_GetMsgLength(CAN_Type *canx, uint8 msg_num)
    833          {
    834            return CAN_GET_MB_CS_LENGTH(canx->MB[msg_num].CS);
   \                     LPLD_CAN_GetMsgLength: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x0109             LSLS     R1,R1,#+4
   \   00000004   0x4408             ADD      R0,R0,R1
   \   00000006   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000010   0x4770             BX       LR               ;; return
    835          }
    836          
    837          /*
    838           * LPLD_CAN_GetData
    839           * 该函数用于获得Msg缓冲区中的数据
    840           * 
    841           * 参数:
    842           *    canx--设置CAN总线通道
    843           *      |__CAN0 --CAN0号模块
    844           *      |__CAN1 --CAN1号模块
    845           *    msg_num 选择需要获得数据的Msg缓冲区
    846           *      |___ MSG_NUM_0 --Msg缓冲区0
    847           *      |___ MSG_NUM_1 --Msg缓冲区1
    848           *      |___ MSG_NUM_2 --Msg缓冲区2
    849           *      |___ MSG_NUM_3 --Msg缓冲区3
    850           *      |___ MSG_NUM_4 --Msg缓冲区4
    851           *      ...... 
    852           *      |___ MSG_NUM_15 --Msg缓冲区15
    853           *    in_length
    854           *      |__获得数据长度
    855           *    *in_buffer
    856           *      |__获得数据的缓冲区
    857           * 输出:
    858           *    无 
    859           */

   \                                 In section .text, align 2, keep-with-next
    860          static void LPLD_CAN_GetData(
    861              CAN_Type *canx, 
    862              uint8     msg_num, 
    863              uint8     in_length, 
    864              uint8    *in_buffer)
    865          {
   \                     LPLD_CAN_GetData: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    866            int i;
    867            uint8  *pMBData;
    868            uint8  *pRecieve  = in_buffer;
    869            uint8  word_num   = (in_length - 1)/ 4; //Get the Message buffer word number
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x1E54             SUBS     R4,R2,#+1
   \   00000006   0x2504             MOVS     R5,#+4
   \   00000008   0xFB94 0xF4F5      SDIV     R4,R4,R5
    870            uint8  rest_bytes = (in_length - 1)% 4; //Get the reset bytes of buffer
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x1E52             SUBS     R2,R2,#+1
   \   00000010   0x2504             MOVS     R5,#+4
   \   00000012   0xFB92 0xF6F5      SDIV     R6,R2,R5
   \   00000016   0xFB05 0x2216      MLS      R2,R5,R6,R2
    871            if(word_num > 0)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD012             BEQ.N    ??LPLD_CAN_GetData_0
    872            {  
    873              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x010D             LSLS     R5,R1,#+4
   \   00000024   0x4405             ADD      R5,R0,R5
   \   00000026   0xF115 0x068B      ADDS     R6,R5,#+139
    874              for(i = 0 ; i < 4 ; i++)   
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0xE003             B.N      ??LPLD_CAN_GetData_1
    875              {
    876                pRecieve[i] = *pMBData--;
   \                     ??LPLD_CAN_GetData_2: (+1)
   \   0000002E   0x7837             LDRB     R7,[R6, #+0]
   \   00000030   0x555F             STRB     R7,[R3, R5]
   \   00000032   0x1E76             SUBS     R6,R6,#+1
    877              }
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_GetData_1: (+1)
   \   00000036   0x2D04             CMP      R5,#+4
   \   00000038   0xDBF9             BLT.N    ??LPLD_CAN_GetData_2
    878              pMBData = (uint8*)&canx->MB[msg_num].WORD1+3;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0x0109             LSLS     R1,R1,#+4
   \   0000003E   0x4408             ADD      R0,R0,R1
   \   00000040   0xF110 0x068F      ADDS     R6,R0,#+143
   \   00000044   0xE004             B.N      ??LPLD_CAN_GetData_3
    879            }
    880            else
    881            {
    882              pMBData = (uint8*)&canx->MB[msg_num].WORD0+3;
   \                     ??LPLD_CAN_GetData_0: (+1)
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x0109             LSLS     R1,R1,#+4
   \   0000004A   0x4408             ADD      R0,R0,R1
   \   0000004C   0xF110 0x068B      ADDS     R6,R0,#+139
    883            }
    884          
    885            for(i = 0; i <= rest_bytes; i++)
   \                     ??LPLD_CAN_GetData_3: (+1)
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0xE006             B.N      ??LPLD_CAN_GetData_4
    886            {
    887              pRecieve[i+(word_num<<2)] = *pMBData--;    
   \                     ??LPLD_CAN_GetData_5: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0xEB15 0x0084      ADDS     R0,R5,R4, LSL #+2
   \   0000005A   0x7831             LDRB     R1,[R6, #+0]
   \   0000005C   0x5419             STRB     R1,[R3, R0]
   \   0000005E   0x1E76             SUBS     R6,R6,#+1
    888            }
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   \                     ??LPLD_CAN_GetData_4: (+1)
   \   00000062   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000064   0x42AA             CMP      R2,R5
   \   00000066   0xDAF5             BGE.N    ??LPLD_CAN_GetData_5
    889          }
   \   00000068   0xBCF0             POP      {R4-R7}
   \   0000006A   0x4770             BX       LR               ;; return
    890          
    891          /*
    892           * LPLD_CAN_WriteData
    893           * 该函数用于向Msg缓冲区中的写数据
    894           * 
    895           * 参数:
    896           *    canx--设置CAN总线通道
    897           *      |__CAN0 --CAN0号模块
    898           *      |__CAN1 --CAN1号模块
    899           *    msg_num 选择需要写数据的Msg缓冲区
    900           *      |___ MSG_NUM_0 --Msg缓冲区0
    901           *      |___ MSG_NUM_1 --Msg缓冲区1
    902           *      |___ MSG_NUM_2 --Msg缓冲区2
    903           *      |___ MSG_NUM_3 --Msg缓冲区3
    904           *      |___ MSG_NUM_4 --Msg缓冲区4
    905           *      ...... 
    906           *      |___ MSG_NUM_15 --Msg缓冲区15
    907           *    in_length
    908           *      |__写入数据长度
    909           *    *in_buffer
    910           *      |__写入数据的缓冲区
    911           * 输出:
    912           *    无 
    913           */

   \                                 In section .text, align 2, keep-with-next
    914          static void LPLD_CAN_WriteData(
    915              CAN_Type *canx, 
    916              uint8     msg_num, 
    917              uint8     in_length, 
    918              uint8    *in_buffer )
    919          {
   \                     LPLD_CAN_WriteData: (+1)
   \   00000000   0xB4FC             PUSH     {R2-R7}
    920            int i;
    921            uint32 word[2] = {0};  
   \   00000002   0x466C             MOV      R4,SP
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE9C4 0x5600      STRD     R5,R6,[R4, #+0]
    922            uint8  word_num   = (in_length - 1)/ 4; //获得 Msg 的Word 值
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x1E54             SUBS     R4,R2,#+1
   \   00000010   0x2504             MOVS     R5,#+4
   \   00000012   0xFB94 0xF4F5      SDIV     R4,R4,R5
    923            uint8  rest_bytes = (in_length - 1)% 4; //获得剩余字节的值
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x1E56             SUBS     R6,R2,#+1
   \   0000001A   0x2704             MOVS     R7,#+4
   \   0000001C   0xFB96 0xF5F7      SDIV     R5,R6,R7
   \   00000020   0xFB07 0x6515      MLS      R5,R7,R5,R6
    924          
    925            if( msg_num >= MSG_MAX_NO || in_length >8)
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x2910             CMP      R1,#+16
   \   00000028   0xDA02             BGE.N    ??LPLD_CAN_WriteData_0
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x2A09             CMP      R2,#+9
   \   0000002E   0xDB00             BLT.N    ??LPLD_CAN_WriteData_1
    926            {
    927                return; 
   \                     ??LPLD_CAN_WriteData_0: (+1)
   \   00000030   0xE055             B.N      ??LPLD_CAN_WriteData_2
    928            }
    929          
    930            if(word_num < 1)
   \                     ??LPLD_CAN_WriteData_1: (+1)
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD115             BNE.N    ??LPLD_CAN_WriteData_3
    931            {
    932              for (i = 0; i <= rest_bytes ; i++)
   \   00000038   0x2200             MOVS     R2,#+0
   \                     ??LPLD_CAN_WriteData_4: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x4295             CMP      R5,R2
   \   0000003E   0xDB42             BLT.N    ??LPLD_CAN_WriteData_5
    933              {
    934                word[word_num] |=  (uint32)in_buffer[i] << (24-(i<<3));
   \   00000040   0x466E             MOV      R6,SP
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0xF856 0x6024      LDR      R6,[R6, R4, LSL #+2]
   \   00000048   0x5C9F             LDRB     R7,[R3, R2]
   \   0000004A   0xEA5F 0x0CC2      LSLS     R12,R2,#+3
   \   0000004E   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   00000052   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000056   0x433E             ORRS     R6,R7,R6
   \   00000058   0x466F             MOV      R7,SP
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0xF847 0x6024      STR      R6,[R7, R4, LSL #+2]
    935              }
   \   00000060   0x1C52             ADDS     R2,R2,#+1
   \   00000062   0xE7EA             B.N      ??LPLD_CAN_WriteData_4
    936            }
    937            else
    938            {
    939              for (i = 0; i < 4; i++)
   \                     ??LPLD_CAN_WriteData_3: (+1)
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0xE014             B.N      ??LPLD_CAN_WriteData_6
    940              {
    941                word[word_num-1] |= (uint32)in_buffer[i] << (24-(i<<3));
   \                     ??LPLD_CAN_WriteData_7: (+1)
   \   00000068   0x466E             MOV      R6,SP
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0xEB06 0x0684      ADD      R6,R6,R4, LSL #+2
   \   00000070   0xF856 0x6C04      LDR      R6,[R6, #-4]
   \   00000074   0x5C9F             LDRB     R7,[R3, R2]
   \   00000076   0xEA5F 0x0CC2      LSLS     R12,R2,#+3
   \   0000007A   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   0000007E   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000082   0x433E             ORRS     R6,R7,R6
   \   00000084   0x466F             MOV      R7,SP
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0xEB07 0x0784      ADD      R7,R7,R4, LSL #+2
   \   0000008C   0xF847 0x6C04      STR      R6,[R7, #-4]
    942              }
   \   00000090   0x1C52             ADDS     R2,R2,#+1
   \                     ??LPLD_CAN_WriteData_6: (+1)
   \   00000092   0x2A04             CMP      R2,#+4
   \   00000094   0xDBE8             BLT.N    ??LPLD_CAN_WriteData_7
    943              for (i = 0; i <= rest_bytes ; i++)
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0xE012             B.N      ??LPLD_CAN_WriteData_8
    944              {
    945                word[word_num] |=  (uint32)in_buffer[i+4] << (24-(i<<3));
   \                     ??LPLD_CAN_WriteData_9: (+1)
   \   0000009A   0x466E             MOV      R6,SP
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0xF856 0x6024      LDR      R6,[R6, R4, LSL #+2]
   \   000000A2   0xEB03 0x0702      ADD      R7,R3,R2
   \   000000A6   0x793F             LDRB     R7,[R7, #+4]
   \   000000A8   0xEA5F 0x0CC2      LSLS     R12,R2,#+3
   \   000000AC   0xF1DC 0x0C18      RSBS     R12,R12,#+24
   \   000000B0   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   000000B4   0x433E             ORRS     R6,R7,R6
   \   000000B6   0x466F             MOV      R7,SP
   \   000000B8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BA   0xF847 0x6024      STR      R6,[R7, R4, LSL #+2]
    946              }
   \   000000BE   0x1C52             ADDS     R2,R2,#+1
   \                     ??LPLD_CAN_WriteData_8: (+1)
   \   000000C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C2   0x4295             CMP      R5,R2
   \   000000C4   0xDAE9             BGE.N    ??LPLD_CAN_WriteData_9
    947            }
    948            canx->MB[msg_num].WORD0 = word[0];
   \                     ??LPLD_CAN_WriteData_5: (+1)
   \   000000C6   0x9A00             LDR      R2,[SP, #+0]
   \   000000C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000CA   0x010B             LSLS     R3,R1,#+4
   \   000000CC   0x4403             ADD      R3,R0,R3
   \   000000CE   0xF8C3 0x2088      STR      R2,[R3, #+136]
    949            canx->MB[msg_num].WORD1 = word[1];
   \   000000D2   0x9A01             LDR      R2,[SP, #+4]
   \   000000D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D6   0x0109             LSLS     R1,R1,#+4
   \   000000D8   0x4408             ADD      R0,R0,R1
   \   000000DA   0xF8C0 0x208C      STR      R2,[R0, #+140]
    950          }
   \                     ??LPLD_CAN_WriteData_2: (+1)
   \   000000DE   0xBCF3             POP      {R0,R1,R4-R7}
   \   000000E0   0x4770             BX       LR               ;; return
    951          
    952          /*
    953           * LPLD_CAN_Transmit_Interrupt
    954           * 该函数用于处理Msg缓冲区发送中断函数
    955           * 
    956           * 参数:
    957           *    canx--设置CAN总线通道
    958           *      |__CAN0 --CAN0号模块
    959           *      |__CAN1 --CAN1号模块
    960           *    msg_num 选择需要处理发送中断的Msg缓冲区
    961           *      |___ MSG_NUM_0 --Msg缓冲区0
    962           *      |___ MSG_NUM_1 --Msg缓冲区1
    963           *      |___ MSG_NUM_2 --Msg缓冲区2
    964           *      |___ MSG_NUM_3 --Msg缓冲区3
    965           *      |___ MSG_NUM_4 --Msg缓冲区4
    966           *      ...... 
    967           *      |___ MSG_NUM_15 --Msg缓冲区15
    968           * 输出:
    969           *    无 
    970           */

   \                                 In section .text, align 2, keep-with-next
    971          void LPLD_CAN_Transmit_Interrupt(CAN_Type *canx, uint8 msg_num)
    972          {
   \                     LPLD_CAN_Transmit_Interrupt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    973            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num))
   \   00000006   0x0021             MOVS     R1,R4
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       LPLD_CAN_Interrupt_GetFlag
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD021             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    974            {
    975             LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
    976             if(canx == CAN0)
   \   0000001E   0x....             LDR.N    R0,??DataTable19_5  ;; 0x40024000
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD10B             BNE.N    ??LPLD_CAN_Transmit_Interrupt_1
    977             {
    978              if( CAN0_ISR[msg_num] != NULL)
   \   00000024   0x....             LDR.N    R0,??DataTable19_28
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD013             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    979              {
    980                CAN0_ISR[msg_num]();
   \   00000030   0x....             LDR.N    R0,??DataTable19_28
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000038   0x4780             BLX      R0
   \   0000003A   0xE00D             B.N      ??LPLD_CAN_Transmit_Interrupt_0
    981              }
    982             }
    983             else if (canx == CAN1)
   \                     ??LPLD_CAN_Transmit_Interrupt_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable19_26  ;; 0x400a4000
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD10A             BNE.N    ??LPLD_CAN_Transmit_Interrupt_0
    984             {
    985              if( CAN1_ISR[msg_num] != NULL)
   \   00000042   0x....             LDR.N    R0,??DataTable19_29
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD004             BEQ.N    ??LPLD_CAN_Transmit_Interrupt_0
    986              {
    987                CAN1_ISR[msg_num]();
   \   0000004E   0x....             LDR.N    R0,??DataTable19_29
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000056   0x4780             BLX      R0
    988              }
    989             }
    990             else
    991             {
    992             }
    993             
    994            }
    995          }
   \                     ??LPLD_CAN_Transmit_Interrupt_0: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    996          
    997          /*
    998           * LPLD_CAN_Receive_Interrupt
    999           * 该函数用于处理Msg缓冲区接收中断函数
   1000           * 
   1001           * 参数:
   1002           *    canx--设置CAN总线通道
   1003           *      |__CAN0 --CAN0号模块
   1004           *      |__CAN1 --CAN1号模块
   1005           *    msg_num 选择需要处理接收中断的Msg缓冲区
   1006           *      |___ MSG_NUM_0 --Msg缓冲区0
   1007           *      |___ MSG_NUM_1 --Msg缓冲区1
   1008           *      |___ MSG_NUM_2 --Msg缓冲区2
   1009           *      |___ MSG_NUM_3 --Msg缓冲区3
   1010           *      |___ MSG_NUM_4 --Msg缓冲区4
   1011           *      ...... 
   1012           *      |___ MSG_NUM_15 --Msg缓冲区15
   1013           * 输出:
   1014           *    无 
   1015           */

   \                                 In section .text, align 2, keep-with-next
   1016          static void LPLD_CAN_Receive_Interrupt(CAN_Type *canx, uint8 msg_num)
   1017          {
   \                     LPLD_CAN_Receive_Interrupt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1018            if(LPLD_CAN_Interrupt_GetFlag(canx,msg_num) == 1)
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       LPLD_CAN_Interrupt_GetFlag
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD112             BNE.N    ??LPLD_CAN_Receive_Interrupt_0
   1019            {
   1020              //如果定义了中断回掉函数，在此执行
   1021              if(canx == CAN0)
   \   00000014   0x....             LDR.N    R0,??DataTable19_5  ;; 0x40024000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD110             BNE.N    ??LPLD_CAN_Receive_Interrupt_1
   1022              {
   1023                if( CAN0_ISR[msg_num] != NULL)
   \   0000001A   0x....             LDR.N    R0,??DataTable19_28
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   1024                {
   1025                    CAN0_ISR[msg_num]();
   \   00000026   0x....             LDR.N    R0,??DataTable19_28
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000002E   0x4780             BLX      R0
   1026                }
   1027              }
   1028              else if (canx == CAN1)
   1029              {
   1030                if( CAN1_ISR[msg_num] != NULL)
   1031                {
   1032                    CAN1_ISR[msg_num]();
   1033                }
   1034              }
   1035              else
   1036              {
   1037                return;
   1038              }
   1039              LPLD_CAN_Interrupt_ClearPending(canx,msg_num);
   \                     ??LPLD_CAN_Receive_Interrupt_2: (+1)
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       LPLD_CAN_Interrupt_ClearPending
   1040            }
   1041          }
   \                     ??LPLD_CAN_Receive_Interrupt_0: (+1)
   \                     ??LPLD_CAN_Receive_Interrupt_3: (+1)
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??LPLD_CAN_Receive_Interrupt_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable19_26  ;; 0x400a4000
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD10B             BNE.N    ??LPLD_CAN_Receive_Interrupt_4
   \   00000042   0x....             LDR.N    R0,??DataTable19_29
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD0F0             BEQ.N    ??LPLD_CAN_Receive_Interrupt_2
   \   0000004E   0x....             LDR.N    R0,??DataTable19_29
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000056   0x4780             BLX      R0
   \   00000058   0xE7EA             B.N      ??LPLD_CAN_Receive_Interrupt_2
   \                     ??LPLD_CAN_Receive_Interrupt_4: (+1)
   \   0000005A   0xE7EE             B.N      ??LPLD_CAN_Receive_Interrupt_3
   1042          /*
   1043           * LPLD_CAN_MB_ISR
   1044           * CANx中断处理函数
   1045           * 
   1046           * 参数:
   1047           *    无
   1048           * 输出:
   1049           *    无 
   1050           */

   \                                 In section .text, align 2, keep-with-next
   1051          static void LPLD_CAN_MB_ISR(void)
   1052          {
   \                     LPLD_CAN_MB_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1053            uint8 msg_obj;
   1054            
   1055            for (msg_obj = 0; msg_obj < MSG_MAX_NO; msg_obj++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE025             B.N      ??LPLD_CAN_MB_ISR_0
   1056            {
   1057              if(flexcan_msgobj_param_t[msg_obj].CAN_Canx != NULL)
   1058              {
   1059                if(flexcan_msgobj_param_t[msg_obj].CAN_MsgDirection == CAN_MSGOBJ_DIR_TX)
   1060                {
   1061                  LPLD_CAN_Transmit_Interrupt(flexcan_msgobj_param_t[msg_obj].CAN_Canx,msg_obj);
   1062                }
   1063                else if(flexcan_msgobj_param_t[msg_obj].CAN_MsgDirection == CAN_MSGOBJ_DIR_RX)
   \                     ??LPLD_CAN_MB_ISR_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable19_30
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x0121             LSLS     R1,R4,#+4
   \   0000000C   0x4408             ADD      R0,R0,R1
   \   0000000E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD11D             BNE.N    ??LPLD_CAN_MB_ISR_2
   1064                {
   1065                  LPLD_CAN_Receive_Interrupt(flexcan_msgobj_param_t[msg_obj].CAN_Canx,msg_obj);
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x....             LDR.N    R0,??DataTable19_30
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x0122             LSLS     R2,R4,#+4
   \   0000001E   0x5880             LDR      R0,[R0, R2]
   \   00000020   0x.... 0x....      BL       LPLD_CAN_Receive_Interrupt
   \   00000024   0xE014             B.N      ??LPLD_CAN_MB_ISR_2
   1066                }
   \                     ??LPLD_CAN_MB_ISR_3: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable19_30
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x0121             LSLS     R1,R4,#+4
   \   0000002C   0x5840             LDR      R0,[R0, R1]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00E             BEQ.N    ??LPLD_CAN_MB_ISR_2
   \   00000032   0x....             LDR.N    R0,??DataTable19_30
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x0121             LSLS     R1,R4,#+4
   \   00000038   0x4408             ADD      R0,R0,R1
   \   0000003A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD1E2             BNE.N    ??LPLD_CAN_MB_ISR_1
   \   00000040   0x0021             MOVS     R1,R4
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x....             LDR.N    R0,??DataTable19_30
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x0122             LSLS     R2,R4,#+4
   \   0000004A   0x5880             LDR      R0,[R0, R2]
   \   0000004C   0x.... 0x....      BL       LPLD_CAN_Transmit_Interrupt
   1067                else
   1068                {}
   1069              }
   1070            }
   \                     ??LPLD_CAN_MB_ISR_2: (+1)
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \                     ??LPLD_CAN_MB_ISR_0: (+1)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C10             CMP      R4,#+16
   \   00000056   0xDBE6             BLT.N    ??LPLD_CAN_MB_ISR_3
   1071          }
   \                     ??LPLD_CAN_MB_ISR_4: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1072          /*
   1073           * CAN0中断处理函数
   1074           * 与启动文件startup_K60.s中的中断向量表关联
   1075           * 用户无需修改，程序自动进入对应通道中断函数
   1076           */

   \                                 In section .text, align 2, keep-with-next
   1077          void CAN0_MESS_IRQHandler(void)
   1078          {
   \                     CAN0_MESS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1079          #if (UCOS_II > 0u)
   1080            OS_CPU_SR  cpu_sr = 0u;
   1081            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1082            OSIntEnter();
   1083            OS_EXIT_CRITICAL();
   1084          #endif
   1085            LPLD_CAN_MB_ISR();
   \   00000002   0x.... 0x....      BL       LPLD_CAN_MB_ISR
   1086          #if (UCOS_II > 0u)
   1087            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1088          #endif
   1089          }      
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1090          //29:  CAM 0 OR'ed Message buffer (0-15)
   1091          

   \                                 In section .text, align 2, keep-with-next
   1092          void CAN0_BUS_OFF_IRQHandler(void)
   1093          {
   1094            CAN0->ESR1 = CAN_ESR1_BOFFINT_MASK;
   \                     CAN0_BUS_OFF_IRQHandler: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1095          }   //38:  CAM 0 Bus Off
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1096          void CAN0_ERR_IRQHandler(void)
   1097          {
   1098            uint32_t status;
   1099          
   1100            status = CAN0->ESR1;
   \                     CAN0_ERR_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19_31  ;; 0x40024020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   1101          
   1102            if( status  & CAN_ESR1_ERRINT_MASK)
   \   00000004   0x0781             LSLS     R1,R0,#+30
   \   00000006   0xD501             BPL.N    ??CAN0_ERR_IRQHandler_0
   1103            {
   1104              CAN0->ESR1 = status;		
   \   00000008   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1105            }	
   1106          }       //39:  CAM 0 Error
   \                     ??CAN0_ERR_IRQHandler_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1107          void CAN0_TW_IRQHandler(void)
   1108          {
   1109            CAN0->ESR1 = CAN_ESR1_TWRNINT_MASK;
   \                     CAN0_TW_IRQHandler: (+1)
   \   00000000   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000004   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1110          }        //40:  CAM 0 Transmit Warning
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1111          void CAN0_RW_IRQHandler(void)
   1112          {
   1113            CAN0->ESR1 = CAN_ESR1_RWRNINT_MASK;
   \                     CAN0_RW_IRQHandler: (+1)
   \   00000000   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000004   0x....             LDR.N    R1,??DataTable19_31  ;; 0x40024020
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1114          }        //41:  CAM 0 Receive Warning
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1115          void CAN0_WAKE_UP_IRQHandler(void){}   //42:  CAM 0 WakeUp
   \                     CAN0_WAKE_UP_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1116          void CAN0_IMEU_IRQHandler(void){}      //43:  CAM 0 Individual Matching Elements Update (IMEU)
   \                     CAN0_IMEU_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1117          void CAN0_LR_IRQHandler(void){}        //44:  CAM 0 Lost receive
   \                     CAN0_LR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1118          
   1119          /*
   1120           * CAN1中断处理函数
   1121           * 与启动文件startup_K60.s中的中断向量表关联
   1122           * 用户无需修改，程序自动进入对应通道中断函数
   1123           */

   \                                 In section .text, align 2, keep-with-next
   1124          void CAN1_MESS_IRQHandler(void)
   1125          {
   \                     CAN1_MESS_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1126          #if (UCOS_II > 0u)
   1127            OS_CPU_SR  cpu_sr = 0u;
   1128            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
   1129            OSIntEnter();
   1130            OS_EXIT_CRITICAL();
   1131          #endif
   1132            LPLD_CAN_MB_ISR();
   \   00000002   0x.... 0x....      BL       LPLD_CAN_MB_ISR
   1133          #if (UCOS_II > 0u)
   1134            OSIntExit();          //告知系统此时即将离开中断服务子函数
   1135          #endif
   1136          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1137          //37:  CAM 1 OR'ed Message buffer (0-15)
   1138          

   \                                 In section .text, align 2, keep-with-next
   1139          void CAN1_BUS_OFF_IRQHandler(void)
   1140          {
   1141            CAN1->ESR1 = CAN_ESR1_BOFFINT_MASK;
   \                     CAN1_BUS_OFF_IRQHandler: (+1)
   \   00000000   0x2004             MOVS     R0,#+4
   \   00000002   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1142          }   //38:  CAM 1 Bus Off
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1143          void CAN1_ERR_IRQHandler(void)
   1144          {
   1145            uint32_t status;
   1146          
   1147            status = CAN1->ESR1;
   \                     CAN1_ERR_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable19_32  ;; 0x400a4020
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   1148          
   1149            if( status  & CAN_ESR1_ERRINT_MASK)
   \   00000004   0x0781             LSLS     R1,R0,#+30
   \   00000006   0xD501             BPL.N    ??CAN1_ERR_IRQHandler_0
   1150            {
   1151              CAN1->ESR1 = status;		
   \   00000008   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1152            }	
   1153          }       //39:  CAM 1 Error
   \                     ??CAN1_ERR_IRQHandler_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1154          void CAN1_TW_IRQHandler(void)
   1155          {
   1156            CAN1->ESR1 = CAN_ESR1_TWRNINT_MASK;
   \                     CAN1_TW_IRQHandler: (+1)
   \   00000000   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000004   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1157          }        //40:  CAM 1 Transmit Warning
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1158          void CAN1_RW_IRQHandler(void)
   1159          {
   1160            CAN1->ESR1 = CAN_ESR1_RWRNINT_MASK;
   \                     CAN1_RW_IRQHandler: (+1)
   \   00000000   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000004   0x....             LDR.N    R1,??DataTable19_32  ;; 0x400a4020
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1161          }        //41:  CAM 1 Receive Warning
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1162          void CAN1_WAKE_UP_IRQHandler(void){}   //42:  CAM 1 WakeUp
   \                     CAN1_WAKE_UP_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1163          void CAN1_IMEU_IRQHandler(void){}      //43:  CAM 1 Individual Matching Elements Update (IMEU)
   \                     CAN1_IMEU_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1164          void CAN1_LR_IRQHandler(void){}        //44:  CAM 1 Lost receive
   \                     CAN1_LR_IRQHandler: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x000F4241         DC32     0xf4241

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x40024000         DC32     0x40024000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x4004A048         DC32     0x4004a048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x4004A04C         DC32     0x4004a04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x40049034         DC32     0x40049034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_15:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_16:
   \   00000000   0x00014585         DC32     0x14585

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_17:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_18:
   \   00000000   0x0001E848         DC32     0x1e848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_19:
   \   00000000   0x0003D090         DC32     0x3d090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_20:
   \   00000000   0x0007A120         DC32     0x7a120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_21:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_22:
   \   00000000   0x........         DC32     g_bus_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_23:
   \   00000000   0x00010003         DC32     0x10003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_24:
   \   00000000   0x009B0002         DC32     0x9b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_25:
   \   00000000   0x005B0002         DC32     0x5b0002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_26:
   \   00000000   0x400A4000         DC32     0x400a4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_27:
   \   00000000   0x1FFC0000         DC32     0x1ffc0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_28:
   \   00000000   0x........         DC32     CAN0_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_29:
   \   00000000   0x........         DC32     CAN1_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_30:
   \   00000000   0x........         DC32     flexcan_msgobj_param_t

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_31:
   \   00000000   0x40024020         DC32     0x40024020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_32:
   \   00000000   0x400A4020         DC32     0x400a4020

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x31          DC8 5CH, 31H, 39H, 30H, 37H, 31H, 5FH, 30H
   \              0x39 0x30    
   \              0x37 0x31    
   \              0x5F 0x30    
   \   00000010   0x30 0x30          DC8 30H, 30H, 5CH, 44H, 65H, 73H, 6BH, 74H
   \              0x5C 0x44    
   \              0x65 0x73    
   \              0x6B 0x74    
   \   00000018   0x6F 0x70          DC8 6FH, 70H, 5CH, 4BH, 36H, 30H, 5FH, 43H
   \              0x5C 0x4B    
   \              0x36 0x30    
   \              0x5F 0x43    
   \   00000020   0x61 0x72          DC8 61H, 72H, 5CH, 6CH, 69H, 62H, 5CH, 4CH
   \              0x5C 0x6C    
   \              0x69 0x62    
   \              0x5C 0x4C    
   \   00000028   0x50 0x4C          DC8 50H, 4CH, 44H, 5CH, 48H, 57H, 5CH, 48H
   \              0x44 0x5C    
   \              0x48 0x57    
   \              0x5C 0x48    
   \   00000030   0x57 0x5F          DC8 57H, 5FH, 43H, 41H, 4EH, 2EH, 63H, 0
   \              0x43 0x41    
   \              0x4E 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0
   \              0x00000000   
   1165          
   1166          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN0_BUS_OFF_IRQHandler
       0   CAN0_ERR_IRQHandler
       0   CAN0_IMEU_IRQHandler
       0   CAN0_LR_IRQHandler
       8   CAN0_MESS_IRQHandler
         8   -> LPLD_CAN_MB_ISR
       0   CAN0_RW_IRQHandler
       0   CAN0_TW_IRQHandler
       0   CAN0_WAKE_UP_IRQHandler
       0   CAN1_BUS_OFF_IRQHandler
       0   CAN1_ERR_IRQHandler
       0   CAN1_IMEU_IRQHandler
       0   CAN1_LR_IRQHandler
       8   CAN1_MESS_IRQHandler
         8   -> LPLD_CAN_MB_ISR
       0   CAN1_RW_IRQHandler
       0   CAN1_TW_IRQHandler
       0   CAN1_WAKE_UP_IRQHandler
       8   LPLD_CAN_Deinit
         8   -> __NVIC_DisableIRQ
         8   -> __NVIC_EnableIRQ
       8   LPLD_CAN_DisableIrq
         8   -> __NVIC_DisableIRQ
       8   LPLD_CAN_EnableIrq
         8   -> __NVIC_EnableIRQ
       0   LPLD_CAN_EnableMsgInterrupt
      16   LPLD_CAN_GetData
       0   LPLD_CAN_GetMsgCode
       0   LPLD_CAN_GetMsgID
       0   LPLD_CAN_GetMsgLength
       0   LPLD_CAN_GetMsgTimeStamp
      40   LPLD_CAN_Init
        40   -> LPLD_CAN_SetBaudRate
        40   -> assert_failed
      32   LPLD_CAN_InitMessageObject
        32   -> LPLD_CAN_EnableMsgInterrupt
       0   LPLD_CAN_Interrupt_ClearPending
       0   LPLD_CAN_Interrupt_GetFlag
       8   LPLD_CAN_MB_ISR
         8   -> LPLD_CAN_Receive_Interrupt
         8   -> LPLD_CAN_Transmit_Interrupt
      16   LPLD_CAN_Receive_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
      48   LPLD_CAN_ReceivedMessage
        48   -> LPLD_CAN_GetData
        48   -> LPLD_CAN_GetMsgCode
        48   -> LPLD_CAN_GetMsgID
        48   -> LPLD_CAN_GetMsgLength
        48   -> LPLD_CAN_GetMsgTimeStamp
        48   -> LPLD_CAN_Interrupt_ClearPending
        48   -> LPLD_CAN_SetMsgCode
        48   -> LPLD_CAN_UnlockMsg
        48   -> memcpy
      16   LPLD_CAN_SetBaudRate
        16   -> assert_failed
       0   LPLD_CAN_SetMsgCode
      56   LPLD_CAN_TransmitMessage
        56   -> LPLD_CAN_GetMsgCode
        56   -> LPLD_CAN_WriteData
      16   LPLD_CAN_Transmit_Interrupt
        16   -- Indirect call
        16   -> LPLD_CAN_Interrupt_ClearPending
        16   -> LPLD_CAN_Interrupt_GetFlag
       0   LPLD_CAN_UnlockMsg
      24   LPLD_CAN_WriteData
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_32
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      56  ?_0
       8  ?_1
       8  CAN0_BUS_OFF_IRQHandler
      14  CAN0_ERR_IRQHandler
       2  CAN0_IMEU_IRQHandler
      64  CAN0_ISR
       2  CAN0_LR_IRQHandler
       8  CAN0_MESS_IRQHandler
      10  CAN0_RW_IRQHandler
      10  CAN0_TW_IRQHandler
       2  CAN0_WAKE_UP_IRQHandler
       8  CAN1_BUS_OFF_IRQHandler
      14  CAN1_ERR_IRQHandler
       2  CAN1_IMEU_IRQHandler
      64  CAN1_ISR
       2  CAN1_LR_IRQHandler
       8  CAN1_MESS_IRQHandler
      10  CAN1_RW_IRQHandler
      10  CAN1_TW_IRQHandler
       2  CAN1_WAKE_UP_IRQHandler
      84  LPLD_CAN_Deinit
      34  LPLD_CAN_DisableIrq
      34  LPLD_CAN_EnableIrq
      34  LPLD_CAN_EnableMsgInterrupt
     108  LPLD_CAN_GetData
      16  LPLD_CAN_GetMsgCode
      50  LPLD_CAN_GetMsgID
      18  LPLD_CAN_GetMsgLength
      14  LPLD_CAN_GetMsgTimeStamp
     520  LPLD_CAN_Init
     188  LPLD_CAN_InitMessageObject
      34  LPLD_CAN_Interrupt_ClearPending
      30  LPLD_CAN_Interrupt_GetFlag
      90  LPLD_CAN_MB_ISR
      92  LPLD_CAN_Receive_Interrupt
     180  LPLD_CAN_ReceivedMessage
     182  LPLD_CAN_SetBaudRate
      32  LPLD_CAN_SetMsgCode
     230  LPLD_CAN_TransmitMessage
      90  LPLD_CAN_Transmit_Interrupt
       6  LPLD_CAN_UnlockMsg
     226  LPLD_CAN_WriteData
      28  __NVIC_DisableIRQ
      28  __NVIC_EnableIRQ
     256  flexcan_msgobj_param_t

 
   384 bytes in section .bss
    64 bytes in section .rodata
 2 592 bytes in section .text
 
 2 592 bytes of CODE  memory
    64 bytes of CONST memory
   384 bytes of DATA  memory

Errors: none
Warnings: none
